{
  "name": "ETL - Zurich",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1376,
        544
      ],
      "id": "ddd5a3a9-8db5-4878-bbd1-a05ba05ea650",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "jsCode": "// ==========================================\n// ETL NORMALIZACIÓN ZURICH - CATÁLOGO MAESTRO DE VEHÍCULOS\n// Versión: 2.0 - Con documentación completa\n// Fecha: 2025-09-03\n// Autor: Sistema ETL Multi-Aseguradora\n// ==========================================\n\n/**\n * PROPÓSITO:\n * Este código normaliza los datos de vehículos de la aseguradora ZURICH\n * para integrarlos en un catálogo maestro unificado. El proceso incluye:\n * 1. Limpieza y normalización de marcas/modelos\n * 2. Extracción de versión (trim) eliminando especificaciones técnicas\n * 3. Detección de transmisión desde campo dedicado y validación en texto\n * 4. Extracción de especificaciones técnicas (motor, tracción, etc.)\n * 5. Generación de hashes únicos para deduplicación\n * \n * IMPORTANTE:\n * - El schema de salida DEBE ser idéntico al del catálogo maestro\n * - Campos vacíos se almacenan como null, no con valores default\n * - La versión vacía se mantiene vacía, no se usa \"BASE\"\n * - Transmisión desconocida es null, no \"DESCONOCIDO\" o \"AUTO\"\n */\n\n// ==========================================\n// CONFIGURACIÓN Y DEPENDENCIAS\n// ==========================================\n\nconst ASEGURADORA = 'ZURICH';\nconst crypto = require('crypto');\n\n// ==========================================\n// FUNCIONES DE UTILIDAD GENERAL\n// ==========================================\n\n/**\n * Normaliza cualquier texto eliminando acentos, caracteres especiales\n * y convirtiendo a mayúsculas. Función base para toda normalización.\n * \n * @param {string} texto - Texto a normalizar\n * @returns {string} Texto normalizado en mayúsculas sin caracteres especiales\n * \n * Ejemplos:\n * - \"Mazda CX-5\" → \"MAZDA CX-5\"\n * - \"Volkswagën\" → \"VOLKSWAGEN\"\n * - \"PICK-UP  4x4\" → \"PICK UP 4X4\"\n */\nfunction normalizarTexto(texto) {\n    if (!texto) return '';\n    return texto.toString()\n        .toUpperCase()\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '') // Elimina acentos\n        .replace(/[^A-Z0-9\\s-]/g, ' ')   // Solo permite letras, números, espacios y guiones\n        .replace(/\\s+/g, ' ')             // Colapsa espacios múltiples\n        .trim();\n}\n\n/**\n * Genera hash SHA-256 para identificación única de vehículos\n * \n * @param {...string} componentes - Componentes a hashear\n * @returns {string} Hash SHA-256 en hexadecimal\n */\nfunction generarHash(...componentes) {\n    const texto = componentes.filter(c => c).join('|').toUpperCase();\n    return crypto.createHash('sha256').update(texto).digest('hex');\n}\n\n// ==========================================\n// NORMALIZACIÓN DE MARCA\n// ==========================================\n\n/**\n * Normaliza nombres de marcas aplicando sinónimos y correcciones comunes.\n * IMPORTANTE: Mantener consistencia entre todas las aseguradoras.\n * \n * @param {string} marca - Nombre original de la marca\n * @returns {string} Marca normalizada y estandarizada\n * \n * Casos especiales manejados:\n * - Variaciones ortográficas (VOLKSWAGEN vs VW)\n * - Errores comunes de escritura (MERCEDES vs MERCEDES BENZ)\n * - Marcas con guiones (LAND ROVER vs LAND-ROVER)\n */\nfunction normalizarMarca(marca) {\n    if (!marca) return '';\n    let marcaNorm = normalizarTexto(marca);\n    \n    // Diccionario exhaustivo de sinónimos y variaciones\n    // MANTENER SINCRONIZADO entre todas las aseguradoras\n    const sinonimos = {\n        'VOLKSWAGEN': ['VW', 'VOLKSWAGEN', 'VOLKS WAGEN'],\n        'MERCEDES BENZ': ['MERCEDES', 'MERCEDES-BENZ', 'MERCEDES BENZ', 'MB', 'MERCEDEZ'],\n        'CHEVROLET': ['CHEVROLET', 'CHEVY', 'CHEV'],\n        'MINI': ['MINI COOPER', 'MINI', 'COOPER'],\n        'LAND ROVER': ['LAND ROVER', 'LANDROVER', 'LAND-ROVER'],\n        'ALFA ROMEO': ['ALFA', 'ALFA ROMEO', 'ALFAROMEO'],\n        'GMC': ['GMC', 'GM', 'GENERAL MOTORS'],\n        'BMW': ['BMW', 'BAYERISCHE MOTOREN WERKE'],\n        'MAZDA': ['MAZDA', 'MATSUDA'],\n        'KIA': ['KIA', 'KIA MOTORS'],\n        'HYUNDAI': ['HYUNDAI', 'HYNDAI', 'HUNDAI'],\n        'MITSUBISHI': ['MITSUBISHI', 'MITSIBUSHI', 'MITS'],\n        'NISSAN': ['NISSAN', 'NISAN', 'DATSUN'],\n        'PEUGEOT': ['PEUGEOT', 'PEUGOT', 'PEUGEOUT'],\n        'RENAULT': ['RENAULT', 'RENOLT', 'RENO'],\n        'SUBARU': ['SUBARU', 'SUBAROO'],\n        'SUZUKI': ['SUZUKI', 'SUSUKI'],\n        'TOYOTA': ['TOYOTA', 'TOYOTTA'],\n        'VOLVO': ['VOLVO', 'VOLVOO'],\n        'ACURA': ['ACURA', 'ACCURA'],\n        'AUDI': ['AUDI', 'AUDII'],\n        'BUICK': ['BUICK', 'BUIK'],\n        'CADILLAC': ['CADILLAC', 'CADILAC'],\n        'CHRYSLER': ['CHRYSLER', 'CRYSLER', 'CRISLER'],\n        'DODGE': ['DODGE', 'DOGDE'],\n        'FERRARI': ['FERRARI', 'FERARI'],\n        'FIAT': ['FIAT', 'FIATT'],\n        'FORD': ['FORD', 'FORT'],\n        'HONDA': ['HONDA', 'JONDA'],\n        'INFINITI': ['INFINITI', 'INFINITY'],\n        'JAGUAR': ['JAGUAR', 'JAGUARR'],\n        'JEEP': ['JEEP', 'JEEEP', 'JEP'],\n        'LAMBORGHINI': ['LAMBORGHINI', 'LAMBO'],\n        'LEXUS': ['LEXUS', 'LEXUSS'],\n        'LINCOLN': ['LINCOLN', 'LINCON'],\n        'MASERATI': ['MASERATI', 'MASSERATI'],\n        'MCLAREN': ['MCLAREN', 'MC LAREN'],\n        'PORSCHE': ['PORSCHE', 'PORCHE', 'PORSHE'],\n        'RAM': ['RAM', 'DODGE RAM'],\n        'ROLLS ROYCE': ['ROLLS ROYCE', 'ROLLS-ROYCE', 'ROLLS'],\n        'SEAT': ['SEAT', 'CEAT'],\n        'SKODA': ['SKODA', 'SCODA'],\n        'TESLA': ['TESLA', 'TESSLA'],\n        'BENTLEY': ['BENTLEY', 'BENTLY'],\n        'GENESIS': ['GENESIS', 'GENISIS'],\n        'SMART': ['SMART', 'SMAR']\n    };\n    \n    // Buscar coincidencias en el diccionario\n    for (const [marcaEstandar, variantes] of Object.entries(sinonimos)) {\n        if (variantes.includes(marcaNorm)) {\n            return marcaEstandar;\n        }\n    }\n    \n    return marcaNorm;\n}\n\n// ==========================================\n// NORMALIZACIÓN DE MODELO\n// ==========================================\n\n/**\n * Normaliza nombres de modelos eliminando redundancias con la marca\n * \n * @param {string} modelo - Nombre original del modelo\n * @param {string} marca - Marca ya normalizada\n * @returns {string} Modelo limpio sin redundancias\n * \n * Ejemplos:\n * - (\"MAZDA 3\", \"MAZDA\") → \"3\"\n * - (\"SERIE 3\", \"BMW\") → \"3 SERIES\"\n * - (\"CLASE A\", \"MERCEDES\") → \"CLASE A\"\n */\nfunction normalizarModelo(modelo, marca) {\n    if (!modelo) return '';\n    let modeloNorm = normalizarTexto(modelo);\n    \n    // Eliminar marca del inicio del modelo si está presente\n    const marcaNorm = normalizarTexto(marca);\n    if (modeloNorm.startsWith(marcaNorm + ' ')) {\n        modeloNorm = modeloNorm.substring(marcaNorm.length + 1);\n    }\n    \n    // Normalización específica de patrones comunes\n    // BMW Serie X → X SERIES\n    modeloNorm = modeloNorm.replace(/^SERIE\\s+(\\d+)/, '$1 SERIES');\n    // Mercedes Clase X → CLASE X\n    modeloNorm = modeloNorm.replace(/^CLASE\\s+([A-Z])/, 'CLASE $1');\n    \n    return modeloNorm;\n}\n\n// ==========================================\n// DETECCIÓN Y NORMALIZACIÓN DE TRANSMISIÓN\n// ==========================================\n\n/**\n * Determina el tipo de transmisión normalizado.\n * PRIORIDAD: Campo código > Texto de versión > null\n * \n * @param {number} codigoTransmision - Código numérico (1=Manual, 2=Auto, 0=No especificado)\n * @param {string} textoVersion - Texto completo de versión para validación\n * @returns {string|null} 'MANUAL', 'AUTO' o null si no se puede determinar\n * \n * IMPORTANTE: CVT y DCT se mapean a 'AUTO' para homologación\n * CVT (Continuously Variable Transmission) = AUTO\n * DCT (Dual Clutch Transmission) = AUTO\n * \n * Lógica de decisión:\n * 1. Si código es 1 → MANUAL\n * 2. Si código es 2 → AUTO\n * 3. Si código es 0 → Buscar en texto\n * 4. Si no se encuentra → null \n */\nfunction normalizarTransmision(codigoTransmision, textoVersion) {\n    // PRIORIDAD 1: Código numérico del campo dedicado\n    if (codigoTransmision === 1) return 'MANUAL';\n    if (codigoTransmision === 2) return 'AUTO';\n    \n    // PRIORIDAD 2: Buscar en texto solo si código es 0 o no especificado\n    if (textoVersion) {\n        const texto = textoVersion.toUpperCase();\n        \n        // Patrones de transmisión manual\n        if (texto.match(/\\b(MANUAL|STD|MAN|MT|ESTANDAR|EST)\\b/)) return 'MANUAL';\n        \n        // Patrones de transmisión automática y sus variantes\n        if (texto.match(/\\b(AUT|AUTO|AUTOMATICA|AUTOMATIC|AT)\\b/)) return 'AUTO';\n        if (texto.match(/\\b(TIPTRONIC|S[\\s-]?TRONIC|STRONIC|STEPTRONIC)\\b/)) return 'AUTO';\n        if (texto.match(/\\b(SPORTMATIC|GEARTRONIC|MULTITRONIC)\\b/)) return 'AUTO';\n        if (texto.match(/\\b(G[\\s-]?TRONIC|DRIVELOGIC|XTRONIC)\\b/)) return 'AUTO';\n        \n        // CVT (Variable continua) - Se mapea a AUTO para homologación\n        if (texto.match(/\\bCVT\\b/)) return 'AUTO';\n        \n        // DCT (Doble embrague) - Se mapea a AUTO para homologación\n        if (texto.match(/\\b(DCT|DSG|PDK|DUAL)\\b/)) return 'AUTO';\n    }\n    \n    // Si no se puede determinar, retornar null \n    return null;\n}\n\n// ==========================================\n// EXTRACCIÓN DE ESPECIFICACIONES TÉCNICAS\n// ==========================================\n\n/**\n * Extrae todas las especificaciones técnicas del texto de versión.\n * Esta información se almacena separada de la versión normalizada.\n * \n * @param {string} version - Texto completo de versión\n * @returns {Object} Objeto con todas las especificaciones encontradas\n * \n * Especificaciones extraídas:\n * - cilindrada_l: Motor en litros (1.5, 2.0, etc.)\n * - numero_cilindros: Cantidad de cilindros (4, 6, 8)\n * - potencia_hp: Potencia en caballos de fuerza\n * - traccion: Sistema de tracción (AWD, 4X4, FWD, etc.)\n * - tipo_carroceria: Tipo de vehículo (SEDAN, SUV, PICKUP, etc.)\n * - numero_puertas: Cantidad de puertas (2, 3, 4, 5)\n * - numero_ocupantes: Capacidad de pasajeros\n * - configuracion_motor: Tipo de motor (V6, L4, TURBO, HYBRID, etc.)\n */\nfunction extraerEspecificaciones(version) {\n    const specs = {\n        cilindrada_l: null,\n        numero_cilindros: null,\n        potencia_hp: null,\n        traccion: null,\n        tipo_carroceria: null,\n        numero_puertas: null,\n        numero_ocupantes: null,\n        configuracion_motor: null\n    };\n    \n    if (!version) return specs;\n    const versionUpper = version.toUpperCase();\n    \n    // ===== CILINDRADA =====\n    // Buscar patrones como 1.5L, 2.0T, 3.5L\n    const cilindradaMatch = versionUpper.match(/(\\d+\\.?\\d*)[LT]/);\n    if (cilindradaMatch) {\n        const cilindrada = parseFloat(cilindradaMatch[1]);\n        // Validar rango razonable (0.5L a 8.0L)\n        if (cilindrada >= 0.5 && cilindrada <= 8.0) {\n            specs.cilindrada_l = cilindrada;\n        }\n    }\n    \n    // ===== NÚMERO DE CILINDROS =====\n    // Buscar patrones como 4CIL, 6CIL, 8CIL\n    const cilindrosMatch = versionUpper.match(/(\\d+)CIL/);\n    if (cilindrosMatch) {\n        const cilindros = parseInt(cilindrosMatch[1]);\n        // Validar rango razonable (2 a 12 cilindros)\n        if (cilindros >= 2 && cilindros <= 12) {\n            specs.numero_cilindros = cilindros;\n        }\n    }\n    \n    // ===== POTENCIA =====\n    // Buscar patrones como 190HP, 350HP\n    const potenciaMatch = versionUpper.match(/(\\d+)HP/);\n    if (potenciaMatch) {\n        const potencia = parseInt(potenciaMatch[1]);\n        // Validar rango razonable (50HP a 1500HP)\n        if (potencia >= 50 && potencia <= 1500) {\n            specs.potencia_hp = potencia;\n        }\n    }\n    \n    // ===== TRACCIÓN =====\n    // Orden de prioridad: términos más específicos primero\n    if (versionUpper.match(/\\b4X4\\b/)) specs.traccion = '4X4';\n    else if (versionUpper.match(/\\b4X2\\b/)) specs.traccion = '4X2';\n    else if (versionUpper.match(/\\bAWD\\b/)) specs.traccion = 'AWD';\n    else if (versionUpper.match(/\\b4WD\\b/)) specs.traccion = '4WD';\n    else if (versionUpper.match(/\\bFWD\\b/)) specs.traccion = 'FWD';\n    else if (versionUpper.match(/\\bRWD\\b/)) specs.traccion = 'RWD';\n    // Sistemas propietarios que equivalen a AWD\n    else if (versionUpper.match(/\\bQUATTRO\\b/)) specs.traccion = 'AWD';\n    else if (versionUpper.match(/\\bXDRIVE\\b/)) specs.traccion = 'AWD';\n    else if (versionUpper.match(/\\b4MATIC\\b/)) specs.traccion = 'AWD';\n    else if (versionUpper.match(/\\b4MOTION\\b/)) specs.traccion = 'AWD';\n    else if (versionUpper.match(/\\bALL[\\s-]?4\\b/)) specs.traccion = 'AWD';\n    else if (versionUpper.match(/\\bEAWD\\b/)) specs.traccion = 'AWD';\n    \n    // ===== TIPO DE CARROCERÍA =====\n    // Detectar el tipo más específico posible\n    if (versionUpper.match(/\\bSEDAN\\b/)) specs.tipo_carroceria = 'SEDAN';\n    else if (versionUpper.match(/\\bSUV\\b/)) specs.tipo_carroceria = 'SUV';\n    else if (versionUpper.match(/\\bCOUPE\\b/)) specs.tipo_carroceria = 'COUPE';\n    else if (versionUpper.match(/\\bCONV(ERTIBLE)?\\b/)) specs.tipo_carroceria = 'CONVERTIBLE';\n    else if (versionUpper.match(/\\b(HB|HATCHBACK)\\b/)) specs.tipo_carroceria = 'HATCHBACK';\n    else if (versionUpper.match(/\\b(PICK[\\s-]?UP|PICKUP)\\b/)) specs.tipo_carroceria = 'PICKUP';\n    else if (versionUpper.match(/\\bVAN\\b/)) specs.tipo_carroceria = 'VAN';\n    else if (versionUpper.match(/\\bWAGON\\b/)) specs.tipo_carroceria = 'WAGON';\n    else if (versionUpper.match(/\\bSPORTBACK\\b/)) specs.tipo_carroceria = 'SPORTBACK';\n    else if (versionUpper.match(/\\bCROSSOVER\\b/)) specs.tipo_carroceria = 'CROSSOVER';\n    else if (versionUpper.match(/\\bMINIVAN\\b/)) specs.tipo_carroceria = 'MINIVAN';\n    \n    // ===== NÚMERO DE PUERTAS =====\n    // Buscar patrón XP donde X es el número\n    const puertasMatch = versionUpper.match(/(\\d+)P\\b/);\n    if (puertasMatch) {\n        const puertas = parseInt(puertasMatch[1]);\n        // Validar rango razonable (2 a 5 puertas)\n        if (puertas >= 2 && puertas <= 5) {\n            specs.numero_puertas = puertas;\n        }\n    } else {\n        // Inferir por tipo de carrocería si no está especificado\n        if (specs.tipo_carroceria === 'SEDAN') specs.numero_puertas = 4;\n        else if (specs.tipo_carroceria === 'COUPE') specs.numero_puertas = 2;\n        else if (specs.tipo_carroceria === 'CONVERTIBLE') specs.numero_puertas = 2;\n        else if (specs.tipo_carroceria === 'SUV') specs.numero_puertas = 5;\n        else if (specs.tipo_carroceria === 'HATCHBACK') specs.numero_puertas = 5;\n        else if (specs.tipo_carroceria === 'PICKUP') specs.numero_puertas = 4;\n    }\n    \n    // ===== NÚMERO DE OCUPANTES =====\n    // Buscar patrón XOCUP donde X es el número\n    const ocupantesMatch = versionUpper.match(/(\\d+)OCUP/);\n    if (ocupantesMatch) {\n        const ocupantes = parseInt(ocupantesMatch[1]);\n        // Validar rango razonable (2 a 23 ocupantes)\n        if (ocupantes >= 2 && ocupantes <= 23) {\n            specs.numero_ocupantes = ocupantes;\n        }\n    }\n    \n    // ===== CONFIGURACIÓN DE MOTOR =====\n    // Construir descripción compuesta del motor\n    const configMotor = [];\n    \n    // Tipo de configuración de cilindros\n    if (versionUpper.match(/\\bV(\\d+)\\b/)) {\n        const vMatch = versionUpper.match(/\\bV(\\d+)\\b/);\n        configMotor.push('V' + vMatch[1]);\n    } else if (versionUpper.match(/\\bL(\\d+)\\b/)) {\n        const lMatch = versionUpper.match(/\\bL(\\d+)\\b/);\n        configMotor.push('L' + lMatch[1]);\n    } else if (versionUpper.match(/\\bI(\\d+)\\b/)) {\n        const iMatch = versionUpper.match(/\\bI(\\d+)\\b/);\n        configMotor.push('I' + iMatch[1]);\n    } else if (versionUpper.match(/\\bH(\\d+)\\b/)) {\n        const hMatch = versionUpper.match(/\\bH(\\d+)\\b/);\n        configMotor.push('H' + hMatch[1]); // Motor boxer\n    }\n    \n    // Características adicionales del motor\n    if (versionUpper.match(/\\bTURBO\\b/)) configMotor.push('TURBO');\n    if (versionUpper.match(/\\b(BITURBO|TWIN[\\s-]?TURBO)\\b/)) {\n        // Reemplazar TURBO si ya existe\n        const index = configMotor.indexOf('TURBO');\n        if (index > -1) configMotor.splice(index, 1);\n        configMotor.push('BITURBO');\n    }\n    if (versionUpper.match(/\\bDIESEL\\b/)) configMotor.push('DIESEL');\n    if (versionUpper.match(/\\b(HYBRID|HIBRIDO)\\b/)) configMotor.push('HYBRID');\n    if (versionUpper.match(/\\bPHEV\\b/)) configMotor.push('PHEV');\n    if (versionUpper.match(/\\bMHEV\\b/)) configMotor.push('MHEV');\n    if (versionUpper.match(/\\bEV\\b|\\bELECTRICO\\b/)) configMotor.push('ELECTRICO');\n    \n    // Unir configuración si hay elementos\n    if (configMotor.length > 0) {\n        specs.configuracion_motor = configMotor.join(' ');\n    }\n    \n    return specs;\n}\n\n// ==========================================\n// NORMALIZACIÓN DE VERSIÓN (TRIM)\n// ==========================================\n\n/**\n * Extrae y normaliza la versión (trim level) del vehículo.\n * CRÍTICO: Elimina TODAS las especificaciones técnicas, dejando solo el trim.\n * \n * @param {string} version - Texto completo de versión del vehículo\n * @param {string} transmisionNormalizada - Transmisión ya detectada (no usado actualmente)\n * @returns {string} Versión limpia solo con trim level o cadena vacía\n * \n * Proceso:\n * 1. Eliminar códigos al inicio (G5J/1, C20, etc.)\n * 2. Eliminar TODA terminología de transmisión\n * 3. Eliminar especificaciones de motor, tracción, carrocería\n * 4. Eliminar equipamiento y códigos técnicos\n * 5. Preservar solo niveles de trim válidos\n * \n * IMPORTANTE: Si no hay trim válido, retornar cadena vacía, NO \"BASE\"\n */\nfunction normalizarVersion(version, transmisionNormalizada) {\n    if (!version) return '';\n    \n    let versionNorm = version.toUpperCase().trim();\n    \n    // ===== PASO 1: ELIMINAR CÓDIGOS AL INICIO =====\n    // Patrones como G5J/1, C20, M4M, etc.\n    versionNorm = versionNorm.replace(/^[A-Z0-9]{1,4}[\\/\\-]?\\d?\\s+/, '');\n    \n    // ===== PASO 2: LISTA EXHAUSTIVA DE ELEMENTOS A ELIMINAR =====\n    const patronesEliminar = [\n        // ----- TRANSMISIONES (TODAS LAS VARIANTES) -----\n        // Tipos específicos de transmisión automática\n        /\\b(TIPTRONIC|S[\\s-]?TRONIC|STRONIC|STEPTRONIC|SPORTMATIC|GEARTRONIC)\\b/gi,\n        /\\b(DSG|CVT|CVTF|DCT|PDK|AMT|SMG|XTRONIC|POWERSHIFT)\\b/gi,\n        /\\b(MULTITRONIC|DUALOGIC|EASYTRONIC|DRIVELOGIC|SPORTSHIFT)\\b/gi,\n        /\\b(7[\\s-]?G[\\s-]?TRONIC|9[\\s-]?G[\\s-]?TRONIC|G[\\s-]?TRONIC)\\b/gi,\n        // Transmisiones básicas\n        /\\b(AUTOMATICA|AUTOMATIC|AUTO|AUT)\\b/gi,\n        /\\b(MANUAL|ESTANDAR|STD|EST|MAN)\\b/gi,\n        /\\b(MT|AT)\\b/gi,\n        // Velocidades\n        /\\b\\d+\\s*(VEL|SPEED|VELOCIDADES?|MARCHAS?|CAMBIOS?)\\b/gi,\n        \n        // ----- MOTOR Y CILINDRADA -----\n        /\\b[VLI]\\d+\\b/gi,                    // V6, L4, I4\n        /\\bH\\d+\\b/gi,                         // H4, H6 (Boxer)\n        /\\b\\d+\\.?\\d*[LT]\\b/gi,                // 2.0L, 1.5T\n        /\\b\\d+\\s*CIL\\b/gi,                    // 4CIL, 6CIL\n        /\\b\\d+\\s*HP\\b/gi,                     // 190HP, 350HP\n        /\\b\\d+\\s*PS\\b/gi,                     // 190PS (caballos métricos)\n        /\\b\\d+\\s*KW\\b/gi,                     // 140KW (kilowatts)\n        // Tecnologías de motor\n        /\\b(TFSI|TDI|TSI|TBI|GDI|CRDI|CDI|HDI|MHEV|HEV|PHEV|BEV|EV)\\b/gi,\n        /\\b(DIESEL|TURBO|BITURBO|TWIN[\\s-]?TURBO|TBO)\\b/gi,\n        /\\b(HIBRIDO|HIBRIDA|HYBRID|ELECTRICO|MILD[\\s-]?HYBRID)\\b/gi,\n        \n        // ----- TRACCIÓN -----\n        /\\b(4X4|4X2|4WD|AWD|FWD|RWD|2WD|ALL4|EAWD)\\b/gi,\n        /\\b(QUATTRO|XDRIVE|4MATIC|4MOTION|ALL[\\s-]?WHEEL[\\s-]?DRIVE)\\b/gi,\n        \n        // ----- CARROCERÍA (solo si es redundante) -----\n        /\\b(SEDAN|HATCHBACK|HB|COUPE|CONV|CONVERTIBLE|WAGON|SPORTBACK)\\b/gi,\n        /\\b(SUV|PICKUP|PICK[\\s-]?UP|VAN|CROSSOVER|MINIVAN)\\b/gi,\n        \n        // ----- CABINA (PICKUPS) -----\n        /\\b(CREW[\\s.]?CAB|CAB[\\s.]?REG|REGULAR[\\s-]?CAB|DOUBLE[\\s-]?CAB)\\b/gi,\n        /\\b(SINGLE[\\s-]?CAB|EXTENDED[\\s-]?CAB|DOBLE[\\s-]?CABINA)\\b/gi,\n        \n        // ----- EQUIPAMIENTO Y CÓDIGOS -----\n        /\\b(AA|EE|CD|BA|QC|VP|ABS|EBD|ESP|TCS|VSC|DSC)\\b/gi,\n        /\\b(MP3|USB|GPS|NAVI|DVD|BT|BLUETOOTH|FBX|FX|FN|RA|DH|CB|CE|CA|CQ)\\b/gi,\n        /\\b(ONSTAR|BEDLINER|LEATHERETTE|PIEL|LEATHER|CLOTH|TELA)\\b/gi,\n        /\\b(SIS[\\s.]?NAV|SIS[\\s.]?ENTRET|CAM[\\s.]?VIS[\\s.]?TRAS)\\b/gi,\n        /\\b(PAQ[\\s.]?ARRAST|PAQ[\\s.]?[A-Z])\\b/gi,\n        /\\bR\\d{2}\\b/gi,                      // R16, R17, R18 (rines)\n        /\\b(IMP|FBX)\\b/gi,\n        \n        // ----- PUERTAS Y OCUPANTES -----\n        /\\b\\d+\\s*P\\b/gi,                      // 2P, 3P, 4P, 5P\n        /\\b\\d+\\s*PTAS?\\b/gi,                  // 2PTAS, 4PTAS\n        /\\b\\d+\\s*PUERTAS?\\b/gi,\n        /\\b\\d+\\s*OCUP\\.?\\b/gi,                // 5OCUP, 7OCUP\n        /\\b\\d+\\s*OCUPANTES?\\b/gi,\n        /\\b\\d+\\s*PASAJEROS?\\b/gi,\n        /\\b\\d+\\s*PLAZAS?\\b/gi,\n        \n        // ----- TÉRMINOS ADICIONALES ESPECÍFICOS DE ZURICH -----\n        /\\b(TA|TB|TC)\\b/gi,                  // Códigos de techo\n        /\\b(DOBLE[\\s-]?RODADA|EXTRA[\\s-]?LARGA)\\b/gi,\n        /\\b(SIN[\\s-]?ASIENTOS[\\s-]?TRASEROS)\\b/gi,\n        /\\b(PASAJE[\\s-]?(URBANO|PERSONAL)|PRO[\\s-]?SUSI)\\b/gi,\n        /\\b(POLYMETAL|BLU[\\s-]?RAY|TECHO[\\s-]?PANORAMICO)\\b/gi,\n        /\\b(AIR[\\s-]?SUSPENSION|WHEELBASE|STANDARD[\\s-]?WHEELBASE|LWB|SWB)\\b/gi,\n        /\\b(DARK|EDITION|BLACK[\\s-]?EDITION|RECHARGE|ULTIMATE)\\b/gi,\n        /\\b(GEN[\\s-]?VI|EDITION[\\s-]?CENTENNIAL|ANNIVERSARY|ANIV)\\b/gi,\n        /\\b\\d+[\\s-]?SEATER\\b/gi,             // 7-SEATER, 5 SEATER\n        /\\b\\d+[\\s-]?AÑOS?\\b/gi,               // 35 AÑOS\n        /\\b(FRONT|REAR)\\b/gi,\n        \n        // ----- NUMERACIÓN Y CÓDIGOS SUELTOS -----\n        /\\b\\d+PS\\b/gi,                        // 250PS\n        /\\b\\d+KWH\\b/gi,                       // 75KWH\n        /\\b(PS|HP|KW|NM|LB-FT)\\b/gi,         // Unidades de potencia/torque\n        \n        // ----- LIMPIAR PUNTUACIÓN -----\n        /[,.;:]/g,\n        /[?¿!¡]/g,\n        /\\(|\\)/g                              // Paréntesis\n    ];\n    \n    // ===== PASO 3: APLICAR TODAS LAS ELIMINACIONES =====\n    for (const patron of patronesEliminar) {\n        versionNorm = versionNorm.replace(patron, ' ');\n    }\n    \n    // ===== PASO 4: LIMPIAR ESPACIOS MÚLTIPLES =====\n    versionNorm = versionNorm.replace(/\\s+/g, ' ').trim();\n    \n    // ===== PASO 5: IDENTIFICAR TRIM VÁLIDO =====\n    // Lista exhaustiva de trims válidos que DEBEN preservarse\n    // Ordenados por prioridad (más específicos primero)\n    const trimsValidos = [\n        // ----- Trims deportivos y premium -----\n        'TYPE S', 'TYPE R', 'TYPE A',\n        'S LINE', 'M SPORT', 'AMG LINE', 'RS LINE', 'R LINE',\n        'M PERFORMANCE', 'AMG', 'RS', 'SS', 'ST', 'GT', 'GTI', 'GTS', 'GTR',\n        'JOHN COOPER WORKS', 'JCW', 'NISMO', 'TRD PRO', 'TRD SPORT', 'TRD OFF-ROAD',\n        \n        // ----- Niveles de equipamiento premium -----\n        'A-SPEC', 'EX-L', 'X-LINE', 'GT-LINE', 'E-TRON',\n        'SELECT', 'DYNAMIC', 'ADVANCE', 'SPORT', 'LUXURY',\n        'PREMIUM', 'ELITE', 'LIMITED', 'EXCLUSIVE', 'ULTIMATE',\n        'SIGNATURE', 'AVENIR', 'TITANIUM', 'PLATINUM',\n        'COMPETITION', 'VELOCE', 'QUADRIFOGLIO', 'QV',\n        'TI', 'SPRINT', 'ESTREMA', 'COMPETIZIONE',\n        \n        // ----- Trims de pickups -----\n        'LARAMIE', 'KING RANCH', 'LARIAT', 'RAPTOR', 'REBEL',\n        'SAHARA', 'RUBICON', 'TRAIL BOSS', 'HIGH COUNTRY',\n        'Z71', 'ZR2', 'DENALI', 'AT4', 'RST', 'LTZ', 'LT', 'LS',\n        'TRADESMAN', 'BIG HORN', 'LONGHORN', 'TEXAS', 'POWER WAGON',\n        'TREMOR', 'WILDTRAK', 'BADLANDS',\n        \n        // ----- Versiones base y medias -----\n        'BASE', 'SE', 'SEL', 'SEL PLUS', 'S', 'SV', 'SL', 'SR', 'SR5',\n        'LE', 'XLE', 'XSE', 'XL', 'XLT', 'DX', 'LX', 'EX', 'SI',\n        'TOURING', 'GRAND TOURING', 'SPORT TOURING',\n        'SLE', 'SLT', 'TERRAIN', 'ELEVATION',\n        \n        // ----- Versiones de lujo -----\n        'ESSENCE', 'PREFERRED', 'AVANTGARDE', 'EXCLUSIVE',\n        'PROGRESSIVE', 'ACTIVE', 'ALLURE', 'FELINE', 'GRIFFE',\n        'TREND', 'STYLE', 'ELEGANCE', 'INTENS', 'ZEN', 'LIFE',\n        'EMOTION', 'REFERENCE', 'XCELLENCE', 'FR', 'CUPRA',\n        \n        // ----- Específicos de marcas -----\n        'AUTOBIOGRAPHY', 'VOGUE', 'VELAR', 'EVOQUE', 'DISCOVERY',\n        'R-DYNAMIC', 'HSE', 'SVR', 'SVO',\n        'QUADRA-TRAC', 'TRAILHAWK', 'OVERLAND', 'SUMMIT',\n        'PRO-4X', 'ARMADA',\n        'COOPER', 'COUNTRYMAN', 'CLUBMAN', 'ICONIC', 'RESERVE',\n        'EXECUTIVE', 'PERFORMANCE', 'EXCELLENCE',\n        \n        // ----- Nomenclaturas especiales -----\n        'SB', 'SBK', // Sportback abreviado\n        'S4', 'S5', 'S6', 'S7', 'S8', // Audi S series\n        'M3', 'M4', 'M5', 'M6', 'M7', 'M8', // BMW M series\n        'X1', 'X2', 'X3', 'X4', 'X5', 'X6', 'X7', // BMW X series\n        'Q2', 'Q3', 'Q4', 'Q5', 'Q7', 'Q8', // Audi Q series\n        '35', '40', '45', '50', '55', '60', // Nomenclatura Audi TFSI\n        \n        // ----- Letras sueltas que pueden ser trim -----\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n        'N', 'O', 'P', 'Q', 'R', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'\n    ];\n    \n    // Buscar el trim válido más relevante\n    let trimEncontrado = '';\n    \n    // Buscar trims compuestos primero (más específicos)\n    for (const trim of trimsValidos) {\n        if (versionNorm.includes(trim)) {\n            trimEncontrado = trim;\n            break;\n        }\n    }\n    \n    // Si no se encontró trim válido, intentar con la primera palabra significativa\n    if (!trimEncontrado) {\n        const palabras = versionNorm.split(' ').filter(p => {\n            return p.length > 0 && \n                   !p.match(/^\\d+$/) &&          // No solo números\n                   p.length <= 20;               // No palabras muy largas (probablemente basura)\n        });\n        \n        // Usar la primera palabra si existe y es significativa\n        if (palabras.length > 0 && palabras[0].length > 1) {\n            trimEncontrado = palabras[0];\n        }\n    }\n    \n    // ===== PASO 6: RETORNAR RESULTADO =====\n    // IMPORTANTE: Si no hay trim, retornar cadena vacía, NO \"BASE\"\n    if (!trimEncontrado || trimEncontrado.length <= 1) {\n        return '';\n    }\n    \n    return trimEncontrado;\n}\n\n// ==========================================\n// PROCESAMIENTO PRINCIPAL\n// ==========================================\n\n/**\n * Procesa todos los registros de entrada y genera el catálogo maestro normalizado\n * \n * FLUJO DE PROCESAMIENTO:\n * 1. Obtener fecha actual para timestamp\n * 2. Para cada registro de entrada:\n *    a. Normalizar marca y modelo\n *    b. Detectar transmisión\n *    c. Extraer versión limpia (trim)\n *    d. Extraer especificaciones técnicas\n *    e. Generar hashes únicos\n *    f. Crear registro con schema estándar\n * 3. Retornar array de registros procesados\n */\n\n// Obtener fecha actual para el proceso\nconst fechaProceso = new Date().toISOString();\n\n// Procesar cada registro\nconst registros = [];\nfor (const item of $input.all()) {\n    const data = item.json;\n    \n    // ===== NORMALIZACIÓN BÁSICA =====\n    const marcaNormalizada = normalizarMarca(data.marca);\n    const modeloNormalizado = normalizarModelo(data.modelo, data.marca);\n    \n    // ===== DETECCIÓN DE TRANSMISIÓN =====\n    // Usa campo código como prioridad, texto como validación\n    const transmisionNormalizada = normalizarTransmision(\n        data.transmision_codigo,\n        data.version_completa\n    );\n    \n    // ===== NORMALIZACIÓN DE VERSIÓN =====\n    // Extrae solo el trim level, elimina toda especificación técnica\n    const versionNormalizada = normalizarVersion(\n        data.version_para_normalizar || data.version_completa,\n        transmisionNormalizada\n    );\n    \n    // ===== EXTRACCIÓN DE ESPECIFICACIONES =====\n    // Toda la información técnica se extrae por separado\n    const specs = extraerEspecificaciones(data.version_completa);\n    \n    // ===== GENERACIÓN DE CONCATENACIONES =====\n    // main_specs: Para identificación comercial básica\n    const mainSpecs = [\n        marcaNormalizada,\n        modeloNormalizado,\n        data.año,\n        transmisionNormalizada\n    ].map(v => v || 'null').join('|'); // Usar 'null' como string para campos vacíos\n    \n    // tech_specs: Para identificación técnica completa\n    const techSpecs = [\n        versionNormalizada || 'null',\n        specs.configuracion_motor || 'null',\n        specs.cilindrada_l || 'null',\n        specs.traccion || 'null',\n        specs.tipo_carroceria || 'null',\n        specs.numero_ocupantes || 'null'\n    ].join('|');\n    \n    // ===== GENERACIÓN DE HASHES =====\n    // Hash comercial: Para deduplicación básica\n    const hashComercial = generarHash(\n        mainSpecs\n    );\n    \n    // Hash técnico: Para deduplicación completa incluyendo specs\n    const hashTecnico = generarHash(\n        mainSpecs,\n        techSpecs\n    );\n    \n    // ===== CREAR REGISTRO CON SCHEMA ESTÁNDAR =====\n    // IMPORTANTE: Este schema DEBE ser idéntico para todas las aseguradoras\n    const registro = {\n        // Datos principales\n        origen_aseguradora: ASEGURADORA,\n        marca: marcaNormalizada,\n        modelo: modeloNormalizado,\n        anio: data.año,\n        transmision: transmisionNormalizada,\n        version: versionNormalizada || null, // null si no hay versión\n        \n        // Especificaciones técnicas (null si no se encontraron)\n        motor_config: specs.configuracion_motor,\n        cilindrada: specs.cilindrada_l,\n        traccion: specs.traccion,\n        carroceria: specs.tipo_carroceria,\n        numero_ocupantes: specs.numero_ocupantes,\n        \n        // Concatenaciones para búsqueda y agrupación\n        main_specs: mainSpecs,\n        tech_specs: techSpecs,\n        \n        // Hashes únicos para deduplicación\n        hash_comercial: hashComercial,\n        hash_tecnico: hashTecnico,\n        \n        // Metadata\n        aseguradoras_disponibles: [ASEGURADORA],\n        fecha_actualizacion: fechaProceso\n    };\n    \n    registros.push(registro);\n}\n\n// Retornar los registros procesados para n8n\nreturn registros.map(item => ({ json: item }));"
      },
      "id": "19c61dba-efa9-42bd-b2f0-df94e24fb709",
      "name": "Normalize Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -976,
        544
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- =====================================================\n-- QUERY DE EXTRACCIÓN PARA ZURICH\n-- Todos los registros (no tiene campo activo = ~38,984)\n-- Optimizado para n8n sin timeout\n-- =====================================================\n\nSELECT \n    'ZURICH' as origen_aseguradora,\n    v.fiId as id_original,\n    m.fcMarca as marca,\n    sm.fcSubMarca as modelo,\n    v.fiModelo as anio,\n    ISNULL(v.VersionCorta, v.fcVersion) as version_original,\n    CASE \n        WHEN v.fiTransmision = 1 THEN 'MANUAL'\n        WHEN v.fiTransmision = 2 THEN 'AUTO'\n        ELSE NULL\n    END as transmision,\n    1 as activo  -- Todos se consideran activos\nFROM zurich.Version v\nINNER JOIN zurich.Marcas m ON v.fiMarcaId = m.fiMarcaId\nINNER JOIN zurich.SubMarcas sm ON v.fiMarcaId = sm.fiMarcaId \n    AND v.fiSubMarcaId = sm.fiSubMarcaId\nWHERE \n    v.fiModelo BETWEEN 2000 AND 2030\nORDER BY m.fcMarca, sm.fcSubMarca, v.fiModelo"
      },
      "id": "1cf5132d-2482-4aca-a36e-4cb5614788ca",
      "name": "Extract Zurich Data",
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1,
      "position": [
        -1184,
        544
      ],
      "credentials": {
        "microsoftSql": {
          "id": "LxcRbE0XllWrNCsR",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// N8N Deduplication Node - Post-Normalization\n// Eliminates duplicates based on hash_tecnico\n\nconst items = $input.all();\n\nif (items.length === 0) {\n    return [];\n}\n\nconst hashesVistos = new Set();\nconst registrosUnicos = [];\n\nfor (const item of items) {\n    const registro = item.json;\n    \n    if (!registro.hash_tecnico) {\n        continue; // Skip records without technical hash\n    }\n    \n    if (hashesVistos.has(registro.hash_tecnico)) {\n        // Duplicate found - skip it\n    } else {\n        // Unique record - keep it\n        hashesVistos.add(registro.hash_tecnico);\n        registrosUnicos.push(registro);\n    }\n}\n\nreturn registrosUnicos.map(item => ({ json: item }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -784,
        544
      ],
      "id": "1cec4696-7546-4241-b8da-ffa934c432b4",
      "name": "Deduplicate by Hash"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -976,
        736
      ],
      "id": "f58cde1d-e448-4a9c-8b44-687d651a4a96",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -576,
        736
      ],
      "id": "bc335527-9259-4697-9f7a-03d1fcf2400d",
      "name": "Convert to File1"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "L9EcoZNWSjGdaMh6",
          "mode": "list",
          "cachedResultName": "Ukuvi — ETL - Insertar y Actualizar"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -576,
        544
      ],
      "id": "a9ddd331-a870-4c6e-ba2d-f40274a146cc",
      "name": "Execute Workflow"
    }
  ],
  "pinData": {
    "When clicking ‘Execute workflow’": [
      {
        "json": {}
      }
    ]
  },
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Extract Zurich Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Data": {
      "main": [
        [
          {
            "node": "Deduplicate by Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Zurich Data": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate by Hash": {
      "main": [
        [
          {
            "node": "Execute Workflow",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "15b5aae4-ef72-45cd-84ed-72e6fab5ca76",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "900709ac205bf412bdd7b3d4452073dce9dfbb650e50cd24da57187d1da44e89"
  },
  "id": "WeCvX2dcSmJEl4jF",
  "tags": []
}