{
  "name": "ETL - HDI",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1360,
        544
      ],
      "id": "c48fa149-b7c7-4dbb-82b3-f08bf36409a6",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "jsCode": "// ==========================================\n// ETL NORMALIZACIÓN HDI - CATÁLOGO MAESTRO DE VEHÍCULOS\n// Versión: 2.5 - Corrección completa y limpieza agresiva\n// Fecha: 2025-09-07\n// Autor: Sistema ETL Multi-Aseguradora\n// ==========================================\n\n/**\n * PROPÓSITO:\n * Normalizar datos de vehículos de la aseguradora HDI para integración\n * en catálogo maestro unificado.\n * \n * CAMBIOS v2.5:\n * - Eliminación AGRESIVA de \"CP PUERTAS\" y todas sus variantes\n * - Eliminación total de \"BASE\" en cualquier posición\n * - Eliminación completa de transmisiones (SPEEDSHIFT, MULTITRONIC, etc.)\n * - Eliminación completa de carrocerías de la versión\n * - Orden de limpieza optimizado (eliminar problemáticos primero)\n * - Validación estricta de versiones resultantes\n */\n\nconst ASEGURADORA = 'HDI';\nconst crypto = require('crypto');\n\n// ==========================================\n// FUNCIONES DE UTILIDAD GENERAL\n// ==========================================\n\n/**\n * Normaliza cualquier texto eliminando acentos y caracteres especiales\n */\nfunction normalizarTexto(texto) {\n    if (!texto) return '';\n    return texto.toString()\n        .toUpperCase()\n        .normalize('NFD')\n        .replace(/[\\u0300-\\u036f]/g, '')\n        .replace(/[^A-Z0-9\\s-]/g, ' ')\n        .replace(/\\s+/g, ' ')\n        .trim();\n}\n\n/**\n * Limpia texto preservando algunos caracteres necesarios\n */\nfunction limpiarTextoCompleto(texto) {\n    if (!texto) return '';\n    \n    return texto\n        .replace(/[\"\"\"'''`´¨]/g, '')\n        .replace(/[\"']/g, '')\n        .replace(/[\\u0022\\u0027]/g, '')\n        .replace(/[\\u201C\\u201D\\u2018\\u2019]/g, '')\n        .replace(/[\\u00AB\\u00BB]/g, '')\n        .replace(/\\\\/g, '/')\n        .replace(/[()]/g, ' ')\n        .replace(/\\s+/g, ' ')\n        .trim();\n}\n\n/**\n * Genera hash SHA-256 para identificación única\n */\nfunction generarHash(...componentes) {\n    const texto = componentes.filter(c => c).join('|').toUpperCase();\n    return crypto.createHash('sha256').update(texto).digest('hex');\n}\n\n// ==========================================\n// NORMALIZACIÓN DE MARCA\n// ==========================================\n\n/**\n * Normaliza nombres de marcas aplicando sinónimos\n */\nfunction normalizarMarca(marca) {\n    if (!marca) return '';\n    let marcaNorm = normalizarTexto(marca);\n    \n    const sinonimos = {\n        'VOLKSWAGEN': ['VW', 'VOLKSWAGEN', 'VOLKS WAGEN'],\n        'MERCEDES BENZ': ['MERCEDES', 'MERCEDES-BENZ', 'MERCEDES BENZ', 'MB', 'MERCEDEZ'],\n        'CHEVROLET': ['CHEVROLET', 'CHEVY', 'CHEV'],\n        'MINI': ['MINI COOPER', 'MINI', 'COOPER'],\n        'LAND ROVER': ['LAND ROVER', 'LANDROVER', 'LAND-ROVER'],\n        'ALFA ROMEO': ['ALFA', 'ALFA ROMEO', 'ALFAROMEO'],\n        'GMC': ['GMC', 'GM', 'GENERAL MOTORS'],\n        'BMW': ['BMW', 'BAYERISCHE MOTOREN WERKE'],\n        'MAZDA': ['MAZDA', 'MATSUDA'],\n        'KIA': ['KIA', 'KIA MOTORS'],\n        'HYUNDAI': ['HYUNDAI', 'HYNDAI', 'HUNDAI'],\n        'MITSUBISHI': ['MITSUBISHI', 'MITSIBUSHI', 'MITS'],\n        'NISSAN': ['NISSAN', 'NISAN', 'DATSUN'],\n        'PEUGEOT': ['PEUGEOT', 'PEUGOT', 'PEUGEOUT'],\n        'RENAULT': ['RENAULT', 'RENOLT', 'RENO'],\n        'SUBARU': ['SUBARU', 'SUBAROO'],\n        'SUZUKI': ['SUZUKI', 'SUSUKI'],\n        'TOYOTA': ['TOYOTA', 'TOYOTTA'],\n        'RAM': ['RAM', 'DODGE RAM'],\n        'SEAT': ['SEAT', 'CUPRA']\n    };\n    \n    for (const [marcaEstandar, variantes] of Object.entries(sinonimos)) {\n        if (variantes.includes(marcaNorm)) {\n            return marcaEstandar;\n        }\n    }\n    \n    return marcaNorm;\n}\n\n/**\n * Normaliza nombres de modelos eliminando redundancias y equipamiento\n */\nfunction normalizarModelo(modelo, marca) {\n    if (!modelo) return '';\n    \n    let modeloNorm = normalizarTexto(modelo);\n    const marcaNorm = normalizarTexto(marca);\n    \n    // Eliminar marca del modelo si está presente\n    if (marcaNorm && modeloNorm.startsWith(marcaNorm)) {\n        modeloNorm = modeloNorm.substring(marcaNorm.length).trim();\n    }\n    \n    // Limpiar paréntesis y contenido\n    modeloNorm = modeloNorm.replace(/\\([^)]*\\)/g, '').trim();\n    \n    // Eliminar equipamiento que no debería estar en modelo\n    modeloNorm = modeloNorm.replace(/\\b(DVD|CD|GPS|NAV|NAVIGATION|BT|BLUETOOTH)\\b/gi, '').trim();\n    modeloNorm = modeloNorm.replace(/\\b(AA|AC|A\\/C|EE|E\\/E)\\b/gi, '').trim();\n    \n    // Limpiar espacios múltiples resultantes\n    modeloNorm = modeloNorm.replace(/\\s+/g, ' ').trim();\n    \n    return modeloNorm;\n}\n\n// ==========================================\n// NORMALIZACIÓN DE TRANSMISIÓN\n// ==========================================\n\n/**\n * Normaliza transmisión usando campo dedicado o detección por texto\n */\nfunction normalizarTransmision(codigo, textoTransmision, versionTexto) {\n    // Prioridad 1: Campo dedicado de transmisión\n    if (textoTransmision) {\n        const trans = normalizarTexto(textoTransmision);\n        \n        // Automáticas\n        if (['AUT', 'AUTOMATICA', 'AUTO', 'AUTOMATIC', 'ATD'].includes(trans)) return 'AUTO';\n        if (['CVT', 'DSG', 'PDK', 'DCT', 'STRONIC', 'TRONIC', '9G TRONIC'].includes(trans)) return 'AUTO';\n        if (['TIP', 'TIPTRONIC', 'S-TRONIC', 'DUALOGIC'].includes(trans)) return 'AUTO';\n        if (['AUTOMATICA ECVT', 'ASG', 'HSD'].includes(trans)) return 'AUTO';\n        \n        // Manuales\n        if (['STD', 'STANDARD', 'ESTANDAR', 'MANUAL', 'MAN'].includes(trans)) return 'MANUAL';\n        if (['SEL', 'SELESPEED', 'GEA', 'MUT', 'MUL'].includes(trans)) return 'MANUAL';\n        if (trans === 'S/A') return 'MANUAL'; // Sin Aire = Manual en HDI\n    }\n    \n    // Prioridad 2: Detectar en texto de versión\n    if (versionTexto) {\n        const texto = normalizarTexto(versionTexto);\n        \n        // Buscar patrones de automática\n        if (/\\b(AUT|AUTO|AUTOMATIC|CVT|DSG|PDK|DCT|TIPTRONIC)\\b/.test(texto)) return 'AUTO';\n        if (/\\b(STRONIC|TRONIC|DUALOGIC|ASG)\\b/.test(texto)) return 'AUTO';\n        \n        // Buscar patrones de manual\n        if (/\\b(STD|STANDARD|MANUAL|MAN|ESTANDAR)\\b/.test(texto)) return 'MANUAL';\n        if (/\\b(SELESPEED|SEL)\\b/.test(texto)) return 'MANUAL';\n    }\n    \n    return null;\n}\n\n// ==========================================\n// EXTRACCIÓN Y NORMALIZACIÓN DE VERSIÓN\n// ==========================================\n\n/**\n * Extrae el trim/versión limpio del campo VersionCorta de HDI\n * \n * CAMBIO v2.5: Limpieza AGRESIVA y orden optimizado\n */\nfunction normalizarVersion(versionCorta) {\n    if (!versionCorta) return '';\n    \n    let texto = limpiarTextoCompleto(versionCorta);\n    texto = normalizarTexto(texto);\n    \n    // === PASO 1: ELIMINAR PATRONES PROBLEMÁTICOS PRIMERO ===\n    \n    // Eliminar \"BASE\" y cualquier cosa que le siga\n    texto = texto.replace(/\\bBASE\\s+CP\\s+PUERTAS?\\b/gi, '');\n    texto = texto.replace(/\\bBASE\\s+CP\\b/gi, '');\n    texto = texto.replace(/\\bBASE\\s+\\w+/gi, '');\n    texto = texto.replace(/\\bBASE\\b/gi, '');\n    \n    // Eliminar \"CP PUERTAS\" y todas sus variantes\n    texto = texto.replace(/\\b\\d+\\s*CP\\s+PUERTAS?\\b/gi, '');\n    texto = texto.replace(/\\bCP\\s+PUERTAS?\\b/gi, '');\n    texto = texto.replace(/\\b\\d+\\s*CP\\b/gi, '');\n    texto = texto.replace(/\\bCP\\b/gi, '');\n    \n    // Eliminar números seguidos de PUERTAS/PTS/P\n    texto = texto.replace(/\\b\\d+\\s*PUERTAS?\\b/gi, '');\n    texto = texto.replace(/\\b\\d+\\s*PTS?\\b/gi, '');\n    texto = texto.replace(/\\b\\d+P\\b/gi, '');\n    texto = texto.replace(/\\bSEDAN\\s*\\d+P/gi, '');\n    texto = texto.replace(/\\bSEDAN\\s*\\d+\\s*PTS?/gi, '');\n    \n    // === PASO 2: ELIMINAR CARROCERÍAS ===\n    texto = texto.replace(/\\b(SEDAN|COUPE|SUV|HATCHBACK|HB)\\b/gi, '');\n    texto = texto.replace(/\\b(CONVERTIBLE|CABRIO|ROADSTER|SPIDER)\\b/gi, '');\n    texto = texto.replace(/\\b(PICKUP|PICK UP|VAN|WAGON|ESTATE)\\b/gi, '');\n    texto = texto.replace(/\\b(CROSSOVER|MINIVAN|SPORTBACK)\\b/gi, '');\n    texto = texto.replace(/\\b(PANEL|CHASIS|CHASSIS|CARGA)\\b/gi, '');\n    \n    // === PASO 3: ELIMINAR TRANSMISIONES Y VARIANTES ===\n    // Transmisiones específicas primero\n    texto = texto.replace(/\\b(SPEEDSHIFT|MULTITRONIC|TIPTRONIC|STEPTRONIC)\\b/gi, '');\n    texto = texto.replace(/\\b(S[\\s-]?TRONIC|STRONIC|SPORTMATIC|GEARTRONIC)\\b/gi, '');\n    texto = texto.replace(/\\b(DSG|CVT|CVTF|DCT|PDK|AMT|SMG|XTRONIC|POWERSHIFT)\\b/gi, '');\n    texto = texto.replace(/\\b(DUALOGIC|EASYTRONIC|DRIVELOGIC|SPORTSHIFT)\\b/gi, '');\n    texto = texto.replace(/\\b(7[\\s-]?G[\\s-]?TRONIC|9[\\s-]?G[\\s-]?TRONIC|G[\\s-]?TRONIC)\\b/gi, '');\n    \n    // Transmisiones genéricas\n    texto = texto.replace(/\\b(AUTOMATICA|AUTOMATIC|AUTO|AUT|AT)\\b/gi, '');\n    texto = texto.replace(/\\b(MANUAL|ESTANDAR|STD|EST|MAN|MT)\\b/gi, '');\n    texto = texto.replace(/\\b(SELESPEED|SEL|GEA|MUT|MUL|ASG|HSD)\\b/gi, '');\n    \n    // Velocidades\n    texto = texto.replace(/\\b\\d+\\s*(VEL|VELOCIDADES?|SPEED|SPD|CAMBIOS?|MARCHAS?)\\b/gi, '');\n    texto = texto.replace(/\\bAT\\d*\\b/gi, '');\n    \n    // === PASO 4: ELIMINAR ESPECIFICACIONES DE MOTOR ===\n    texto = texto.replace(/\\b[VIL]?\\d+[VIL]?\\b/gi, '');\n    texto = texto.replace(/\\b\\d+\\.?\\d*[LT]\\b/gi, '');\n    texto = texto.replace(/\\b\\d+\\.?\\d*\\s*L(ITROS?|TS?)?\\b/gi, '');\n    texto = texto.replace(/\\b\\d+\\s*(CC|CM3|CILINDROS?|CYL|CIL)\\b/gi, '');\n    texto = texto.replace(/\\b(TURBO|BITURBO|TWINTURBO|TSI|TDI|TFSI|FSI)\\b/gi, '');\n    texto = texto.replace(/\\b(VTEC|VVTI|VVT-I|MIVEC|SKYACTIV)\\b/gi, '');\n    \n    // === PASO 5: ELIMINAR POTENCIA ===\n    texto = texto.replace(/\\b\\d+\\s*(HP|CV|CP|BHP|PS|KW)\\b/gi, '');\n    texto = texto.replace(/\\b\\d+\\s*(CABALLOS?|HORSES?)\\b/gi, '');\n    \n    // === PASO 6: ELIMINAR TRACCIÓN ===\n    texto = texto.replace(/\\b(AWD|4WD|4X4|4X2|FWD|RWD|2WD)\\b/gi, '');\n    texto = texto.replace(/\\b(QUATTRO|XDRIVE|4MATIC|4MOTION|ALL4)\\b/gi, '');\n    texto = texto.replace(/\\b(TRACCION\\s*(DELANTERA|TRASERA|INTEGRAL))\\b/gi, '');\n    \n    // === PASO 7: ELIMINAR COMBUSTIBLE ===\n    texto = texto.replace(/\\b(DIESEL|GASOLINA|HIBRIDO|HYBRID|ELECTRICO|ELECTRIC|EV)\\b/gi, '');\n    texto = texto.replace(/\\b(TDI|HDI|CRDI|CDTI|DCI|BLUEHDI)\\b/gi, '');\n    \n    // === PASO 8: ELIMINAR OCUPANTES ===\n    texto = texto.replace(/\\b\\d+\\s*(PASAJEROS?|OCUPANTES?|PLAZAS?|ASIENTOS?|PAX|PAS)\\b/gi, '');\n    texto = texto.replace(/\\bPASAJEROS?\\b/gi, '');\n    \n    // === PASO 9: ELIMINAR EQUIPAMIENTO ===\n    texto = texto.replace(/\\b(AA|AC|A\\/C|EE|E\\/E|BA|CD|DVD|GPS|NAV|BT|BLUETOOTH)\\b/gi, '');\n    texto = texto.replace(/\\b(VDC|ABS|EBD|ESP|TCS|VSC|DSC)\\b/gi, '');\n    texto = texto.replace(/\\b(DH|TA|VENTANAS?|QC)\\b/gi, '');\n    texto = texto.replace(/\\bR\\d{2}\\b/gi, '');\n    \n    // === PASO 10: ELIMINAR PALABRAS FUNCIONALES ===\n    texto = texto.replace(/\\b(AMPLIA|TOLDO\\s*ALTO)\\b/gi, '');\n    texto = texto.replace(/\\b(AMBULANCIA)\\b/gi, ''); // Mover a carrocería, no versión\n    \n    // === LIMPIEZA FINAL ===\n    texto = texto.replace(/,/g, ' ');\n    texto = texto.replace(/\\s+/g, ' ').trim();\n    \n    // === VALIDACIÓN ===\n    \n    // Si quedó vacío o es solo números/una letra\n    if (!texto || texto.match(/^\\d+$/) || texto.match(/^[A-Z]$/)) {\n        return '';\n    }\n    \n    // Si es una palabra sospechosa sola\n    const palabrasInvalidas = ['CIL', 'CILINDROS', 'PASAJEROS', 'CARGA'];\n    if (palabrasInvalidas.includes(texto)) {\n        return '';\n    }\n    \n    // Lista de trims válidos conocidos (sin BASE)\n    const trimsValidos = new Set([\n        // Niveles de equipamiento comunes\n        'EXCLUSIVE', 'ADVANCE', 'SENSE', 'SR',\n        'GL', 'GLS', 'GLX', 'GT', 'GTI', 'GTS',\n        'SPORT', 'DEPORTIVO', 'ELEGANCE', 'LUXURY',\n        'LIMITED', 'PREMIUM', 'ULTIMATE', 'PLATINUM',\n        'S', 'SE', 'SEL', 'SL', 'SLE', 'SLT', 'SV',\n        'LE', 'LT', 'LTZ', 'LS', 'LSX', 'LX', 'LXI',\n        'EX', 'EXL', 'DX', 'DXL', 'RS', 'RST',\n        // Nombres específicos\n        'LATITUDE', 'LONGITUDE', 'ALTITUDE',\n        'CLASSIC', 'COMFORT', 'DYNAMIC', 'PRESTIGE',\n        'ACTIVE', 'ALLURE', 'FELINE', 'GRIFFE',\n        'TRENDLINE', 'COMFORTLINE', 'HIGHLINE',\n        'STYLE', 'XCELLENCE', 'FR',\n        'LIFE', 'INTENS', 'ZEN', 'INTENSE',\n        'ACCESS', 'PLAY', 'ICON', 'TECHNO',\n        'ESSENTIAL', 'EVOLUTION', 'EXCELLENCE',\n        'REFERENCE', 'STYLE PLUS', 'XCELLENCE PLUS',\n        'AMBITION', 'ELEGANCE', 'LAURIN KLEMENT',\n        'SCOUT', 'MONTE CARLO', 'SPORTLINE',\n        'ACTIVE PLUS', 'AMBITION PLUS', 'STYLE PLUS',\n        'INSPIRE', 'REFINE',\n        // Performance\n        'AMG', 'M', 'RS', 'GTI', 'ST', 'SRT', 'SS', 'R',\n        'JOHN COOPER WORKS', 'JCW', 'ABARTH',\n        // Ediciones especiales\n        'ANNIVERSARY', 'EDITION', 'SPECIAL', 'BLACK', 'WHITE'\n    ]);\n    \n    // Buscar trim válido\n    const palabras = texto.split(' ').filter(p => p.length > 0);\n    \n    // Si es un trim conocido exacto\n    if (trimsValidos.has(texto)) {\n        return texto;\n    }\n    \n    // Verificar trims compuestos (2-3 palabras)\n    for (let i = 0; i < palabras.length - 2; i++) {\n        const compuesto3 = `${palabras[i]} ${palabras[i + 1]} ${palabras[i + 2]}`;\n        if (trimsValidos.has(compuesto3)) {\n            return compuesto3;\n        }\n    }\n    \n    for (let i = 0; i < palabras.length - 1; i++) {\n        const compuesto2 = `${palabras[i]} ${palabras[i + 1]}`;\n        if (trimsValidos.has(compuesto2)) {\n            return compuesto2;\n        }\n    }\n    \n    // Buscar trim simple válido\n    for (const palabra of palabras) {\n        if (trimsValidos.has(palabra)) {\n            return palabra;\n        }\n    }\n    \n    // Si contiene AMG pero no otras cosas problemáticas\n    if (texto.includes('AMG') && !texto.match(/\\d/)) {\n        return 'AMG';\n    }\n    \n    // Si es una sola palabra razonable (2-15 caracteres)\n    if (palabras.length === 1 && palabras[0].length >= 2 && palabras[0].length <= 15) {\n        // Excluir S sola si no está en la lista de válidos\n        if (palabras[0] === 'S') return 'S';\n        if (!palabras[0].match(/^(AT|MT|CVT|DSG)$/)) {\n            return palabras[0];\n        }\n    }\n    \n    // Si son 2-3 palabras y parecen un trim compuesto\n    if (palabras.length >= 2 && palabras.length <= 3) {\n        const trimFinal = palabras.join(' ');\n        // Verificar que no contenga palabras problemáticas\n        if (!trimFinal.match(/\\b(AT|MT|CVT|DSG|SEDAN|COUPE|SUV)\\b/)) {\n            return trimFinal;\n        }\n    }\n    \n    return '';\n}\n\n// ==========================================\n// EXTRACCIÓN DE ESPECIFICACIONES TÉCNICAS\n// ==========================================\n\n/**\n * Extrae especificaciones técnicas del campo VersionCorta de HDI\n */\nfunction extraerEspecificaciones(versionCorta, numeroOcupantesOriginal) {\n    const texto = normalizarTexto(versionCorta || '');\n    const specs = {\n        configuracion_motor: null,\n        cilindrada_l: null,\n        traccion: null,\n        tipo_carroceria: null,\n        numero_ocupantes: null\n    };\n    \n    // === Número de ocupantes/pasajeros ===\n    const ocupantesMatch = texto.match(/(\\d+)\\s*(PASAJEROS?|OCUPANTES?|PLAZAS?|ASIENTOS?|PAX|PAS)\\b/i);\n    if (ocupantesMatch) {\n        const ocupantes = parseInt(ocupantesMatch[1]);\n        if (ocupantes >= 2 && ocupantes <= 23) {\n            specs.numero_ocupantes = ocupantes;\n        }\n    }\n    \n    // === Configuración de Motor ===\n    const motorMatch = texto.match(/\\b([VIL]\\d+[VILT]?)\\b/i);\n    if (motorMatch) {\n        specs.configuracion_motor = motorMatch[1].toUpperCase();\n    }\n    \n    if (!specs.configuracion_motor) {\n        const motorSimple = texto.match(/\\b([LV]\\d)\\b/i);\n        if (motorSimple) {\n            specs.configuracion_motor = motorSimple[1].toUpperCase();\n        }\n    }\n    \n    // Detectar turbo\n    if (/\\b(TURBO|BITURBO|TWINTURBO|TSI|TDI|TFSI)\\b/i.test(texto)) {\n        specs.configuracion_motor = specs.configuracion_motor ? \n            `${specs.configuracion_motor} TURBO` : 'TURBO';\n    }\n    \n    // === Cilindrada ===\n    const cilindradaMatch = texto.match(/(\\d+\\.?\\d*)\\s*[LT]\\b/i);\n    if (cilindradaMatch) {\n        const cilindrada = parseFloat(cilindradaMatch[1]);\n        // Validar rango razonable\n        if (cilindrada >= 0.5 && cilindrada < 8.0) {\n            specs.cilindrada_l = cilindrada;\n        } else if (cilindrada === 8.0 && texto.includes('8.0L')) {\n            // Solo aceptar 8.0L si está explícitamente escrito\n            specs.cilindrada_l = cilindrada;\n        }\n    }\n    \n    // === Tracción ===\n    if (/\\b(AWD|ALL\\s*WHEEL|QUATTRO|XDRIVE|4MATIC)\\b/i.test(texto)) {\n        specs.traccion = 'AWD';\n    } else if (/\\b(4X4|4WD|FOUR\\s*WHEEL)\\b/i.test(texto)) {\n        specs.traccion = '4X4';\n    } else if (/\\b(FWD|FRONT\\s*WHEEL|TRACCION\\s*DELANTERA)\\b/i.test(texto)) {\n        specs.traccion = 'FWD';\n    } else if (/\\b(RWD|REAR\\s*WHEEL|TRACCION\\s*TRASERA)\\b/i.test(texto)) {\n        specs.traccion = 'RWD';\n    }\n    \n    // === Tipo de Carrocería ===\n    // Incluir AMBULANCIA como tipo de carrocería especial\n    if (/\\b(AMBULANCIA)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'VAN'; // Ambulancia es tipo VAN\n    } else if (/\\b(PICK\\s*UP|TRUCK|CAMIONETA)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'PICKUP';\n    } else if (/\\b(CHASIS\\s*CABINA|CHASSIS)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'CHASSIS';\n    } else if (/\\b(PANEL|CARGO\\s*VAN|VAN)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'VAN';\n    } else if (/\\b(SUV|SPORT\\s*UTILITY|CROSSOVER|CUV)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'SUV';\n    } else if (/\\b(SEDAN|BERLINE|SALOON)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'SEDAN';\n    } else if (/\\b(HATCHBACK|HB|COMPACTO)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'HATCHBACK';\n    } else if (/\\b(COUPE|COUP[EÉ])\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'COUPE';\n    } else if (/\\b(CONVERTIBLE|CABRIO|ROADSTER)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'CONVERTIBLE';\n    } else if (/\\b(WAGON|ESTATE|FAMILIAR|TOURER)\\b/i.test(texto)) {\n        specs.tipo_carroceria = 'WAGON';\n    } else {\n        // Intentar inferir por número de puertas\n        const puertasMatch = texto.match(/(\\d+)\\s*PUERTAS?/i);\n        if (puertasMatch) {\n            const puertas = parseInt(puertasMatch[1]);\n            if (puertas === 2) {\n                specs.tipo_carroceria = 'COUPE';\n            } else if (puertas === 3) {\n                specs.tipo_carroceria = 'HATCHBACK';\n            } else if (puertas === 4) {\n                specs.tipo_carroceria = 'SEDAN';\n            } else if (puertas === 5) {\n                specs.tipo_carroceria = 'SUV';\n            }\n        }\n    }\n    \n    // === Número de Ocupantes (si no se detectó antes) ===\n    if (!specs.numero_ocupantes && numeroOcupantesOriginal) {\n        const ocupantes = parseInt(numeroOcupantesOriginal);\n        if (ocupantes >= 2 && ocupantes <= 23) {\n            specs.numero_ocupantes = ocupantes;\n        }\n    }\n    \n    return specs;\n}\n\n// ==========================================\n// PROCESAMIENTO PRINCIPAL\n// ==========================================\n\nconst fechaProceso = new Date().toISOString();\nconst registros = [];\n\nfor (const item of $input.all()) {\n    const data = item.json;\n    \n    // === PASO 1: NORMALIZACIÓN BÁSICA ===\n    const marcaNormalizada = normalizarMarca(data.marca);\n    const modeloNormalizado = normalizarModelo(data.modelo, data.marca);\n    \n    // === PASO 2: DETECCIÓN DE TRANSMISIÓN ===\n    const transmisionNormalizada = normalizarTransmision(\n        data.transmision_codigo,\n        data.transmision_texto,\n        data.version_corta || data.version_original\n    );\n    \n    // === PASO 3: NORMALIZACIÓN DE VERSIÓN ===\n    const versionNormalizada = normalizarVersion(\n        data.version_corta || data.version_original\n    );\n    \n    // === PASO 4: EXTRACCIÓN DE ESPECIFICACIONES ===\n    const specs = extraerEspecificaciones(\n        data.version_corta || data.version_original,\n        data.numero_ocupantes_original\n    );\n    \n    // === PASO 5: GENERAR CONCATENACIONES (ORDEN CRÍTICO) ===\n    const mainSpecs = [\n        marcaNormalizada,\n        modeloNormalizado,\n        data.año,\n        transmisionNormalizada\n    ].map(v => v || 'null').join('|');\n    \n    const techSpecs = [\n        versionNormalizada || 'null',\n        specs.configuracion_motor || 'null',\n        specs.cilindrada_l || 'null',\n        specs.traccion || 'null',\n        specs.tipo_carroceria || 'null',\n        specs.numero_ocupantes || 'null'\n    ].join('|');\n    \n    // === PASO 6: GENERAR HASHES ===\n    const hashComercial = generarHash(mainSpecs);\n    const hashTecnico = generarHash(mainSpecs, techSpecs);\n    \n    // === PASO 7: CREAR REGISTRO CON SCHEMA ESTÁNDAR ===\n    const registro = {\n        // Identificación\n        origen_aseguradora: ASEGURADORA,\n        \n        // Datos principales\n        marca: marcaNormalizada,\n        modelo: modeloNormalizado,\n        anio: data.año,\n        transmision: transmisionNormalizada,\n        version: versionNormalizada || null,\n        \n        // Especificaciones técnicas\n        motor_config: specs.configuracion_motor,\n        cilindrada: specs.cilindrada_l,\n        traccion: specs.traccion,\n        carroceria: specs.tipo_carroceria,\n        numero_ocupantes: specs.numero_ocupantes,\n        \n        // Concatenaciones\n        main_specs: mainSpecs,\n        tech_specs: techSpecs,\n        \n        // Hashes únicos\n        hash_comercial: hashComercial,\n        hash_tecnico: hashTecnico,\n        \n        // Metadata\n        aseguradoras_disponibles: [ASEGURADORA],\n        fecha_actualizacion: fechaProceso\n    };\n    \n    registros.push(registro);\n}\n\n// Retornar para n8n\nreturn registros.map(item => ({ json: item }));"
      },
      "id": "c7bc4338-e28b-4834-88b7-0e90afd1283a",
      "name": "Normalize Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -976,
        544
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- =====================================================\n-- QUERY DE EXTRACCIÓN PARA HDI\n-- Solo registros ACTIVOS (45.15% del total = ~38,186)\n-- Estructura con separación por comas muy limpia\n-- =====================================================\n\nWITH MarcasUnicas AS (\n    -- HDI tiene duplicados en tabla Marca, necesitamos DISTINCT\n    SELECT DISTINCT IdMarca, Descripcion\n    FROM hdi.Marca\n)\nSELECT \n    'HDI' as origen_aseguradora,\n    v.IdVersion as id_original,\n    m.Descripcion as marca,\n    v.ClaveSubMarca as modelo,\n    v.Anio as anio,\n    v.ClaveVersion as version_original,\n    -- No hay campo de transmisión directo, se extrae del texto\n    NULL as transmision,  -- Se procesará en n8n\n    v.Activo as activo\nFROM hdi.Version v\nLEFT JOIN MarcasUnicas m ON v.IdMarca = m.IdMarca\nWHERE \n    v.Activo = 1  -- CRÍTICO: Solo activos (45% del total)\n    AND v.Anio BETWEEN 2000 AND 2030\nORDER BY m.Descripcion, v.ClaveSubMarca, v.Anio"
      },
      "id": "ebea9238-a965-47a1-857c-0455215adc57",
      "name": "Extract HDI Data",
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1,
      "position": [
        -1168,
        544
      ],
      "credentials": {
        "microsoftSql": {
          "id": "LxcRbE0XllWrNCsR",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Nodo: Deduplicate by Hash - CRÍTICO para evitar duplicados\nconst items = $input.all();\nconst uniqueByHash = new Map();\nconst duplicates = new Map();\n\n// Procesar todos los items\nitems.forEach(item => {\n  const hash = item.json.hash_tecnico;\n  \n  if (!hash) {\n    return;\n  }\n  \n  if (uniqueByHash.has(hash)) {\n    // Contar duplicados\n    if (!duplicates.has(hash)) {\n      duplicates.set(hash, [uniqueByHash.get(hash)]);\n    }\n    duplicates.set(hash, [...duplicates.get(hash), item]);\n  } else {\n    uniqueByHash.set(hash, item);\n  }\n});\n\n// Reportar duplicados encontrados\nif (duplicates.size > 0) {  \n  // Mostrar ejemplos de duplicados\n  let exampleCount = 0;\n  for (const [hash, items] of duplicates.entries()) {\n    if (exampleCount >= 5) break;\n    \n    console.log(`\\n🔍 Hash duplicado: ${hash.substring(0, 16)}...`);\n    console.log(`   Registros: ${items.length}`);\n    \n    // Mostrar los primeros 2 registros del duplicado\n    items.slice(0, 2).forEach((item, idx) => {\n      const data = item.json;\n    });\n    \n    exampleCount++;\n  }\n  \n  // Análisis de por qué se duplican\n  const duplicateAnalysis = new Map();\n  for (const [hash, items] of duplicates.entries()) {\n    const firstItem = items[0].json;\n    const key = `${firstItem.marca_normalizada}|${firstItem.modelo_normalizado}`;\n    \n    if (!duplicateAnalysis.has(key)) {\n      duplicateAnalysis.set(key, 0);\n    }\n    duplicateAnalysis.set(key, duplicateAnalysis.get(key) + 1);\n  }\n  \n  const sortedAnalysis = Array.from(duplicateAnalysis.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10);\n  \n  sortedAnalysis.forEach(([key, count]) => {\n    console.log(`   ${key}: ${count} hashes duplicados`);\n  });\n}\n\n// Estadísticas finales\nconst finalItems = Array.from(uniqueByHash.values());\n\nreturn finalItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -784,
        544
      ],
      "id": "6b678f25-f90c-4dd2-b8b5-c837d063575e",
      "name": "Deduplicate by Hash"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -592,
        752
      ],
      "id": "4d14069f-a4d9-433b-9b50-af28a84aa3a7",
      "name": "Convert to File"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -976,
        752
      ],
      "id": "a95722fa-283c-4f0a-b43b-d2f6ba2ce3c2",
      "name": "Convert to File1"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "L9EcoZNWSjGdaMh6",
          "mode": "list",
          "cachedResultName": "Ukuvi — ETL - Insertar y Actualizar"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.2,
      "position": [
        -592,
        544
      ],
      "id": "3d164a5b-881b-4638-82ce-db839850e6dd",
      "name": "Execute Workflow"
    }
  ],
  "pinData": {
    "When clicking ‘Execute workflow’": [
      {
        "json": {}
      }
    ]
  },
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Extract HDI Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Data": {
      "main": [
        [
          {
            "node": "Deduplicate by Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract HDI Data": {
      "main": [
        [
          {
            "node": "Convert to File1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate by Hash": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "b9b03b04-3e53-48d6-8357-9d146ad56941",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "900709ac205bf412bdd7b3d4452073dce9dfbb650e50cd24da57187d1da44e89"
  },
  "id": "o0KVFpedG1yO6vsH",
  "tags": []
}