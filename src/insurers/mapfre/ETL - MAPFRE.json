{
  "name": "ETL - MAPFRE",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1376,
        544
      ],
      "id": "0baee1ad-38c0-475c-8655-c66a3c8232b6",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\nconst ASEGURADORA = 'MAPFRE';\n\n// ==================================================\n// DICCIONARIO DE MARCAS CANÓNICAS\n// ==================================================\nconst MARCAS_CANONICAS = {\n    'MERCEDES-BENZ': ['MERCEDES', 'MERCEDES BENZ', 'BENZ', 'MB'],\n    'BMW': ['BMW', 'BAYERISCHE MOTOREN WERKE', 'BMW BW'],\n    'AUDI': ['AUDI', 'AU', 'AUDI II'],\n    'VOLKSWAGEN': ['VW', 'VOLKS', 'VOLKSWAGON', 'V.W.'],\n    'CHEVROLET': ['CHEVY', 'CHEV', 'CHEVROLET'],\n    'FORD': ['FORD', 'FD'],\n    'TOYOTA': ['TOYOTA', 'TOY'],\n    'NISSAN': ['NISSAN', 'DATSUN'],\n    'HONDA': ['HONDA', 'HON'],\n    'MAZDA': ['MAZDA', 'MAZ'],\n    'KIA': ['KIA MOTORS', 'KIA'],\n    'HYUNDAI': ['HYUNDAI', 'HYU'],\n    'MITSUBISHI': ['MITSU', 'MITSUBISHI'],\n    'JEEP': ['JEEP', 'JP'],\n    'GMC': ['GMC', 'GENERAL MOTORS'],\n    'ALFA ROMEO': ['ALFA', 'ALFA ROMEO'],\n    'LAND ROVER': ['LAND ROVER', 'ROVER'],\n    'MINI': ['MINI COOPER', 'MINI'],\n    'SEAT': ['SEAT', 'ST'],\n    'PEUGEOT': ['PEUGEOT', 'PEU'],\n    'RENAULT': ['RENAULT', 'REN'],\n    'FIAT': ['FIAT', 'FT'],\n    'CHRYSLER': ['CHRYSLER', 'CHRYS'],\n    'DODGE': ['DODGE', 'RAM'],\n    'LINCOLN': ['LINCOLN', 'LINC'],\n    'CADILLAC': ['CADILLAC', 'CADDY'],\n    'INFINITI': ['INFINITI', 'INF'],\n    'ACURA': ['ACURA', 'ACU'],\n    'LEXUS': ['LEXUS', 'LEX'],\n    'SUBARU': ['SUBARU', 'SUB'],\n    'SUZUKI': ['SUZUKI', 'SUZ'],\n    'PORSCHE': ['PORSCHE', 'POR'],\n    'JAGUAR': ['JAGUAR', 'JAG'],\n    'VOLVO': ['VOLVO', 'VOL'],\n    'TESLA': ['TESLA', 'TSL'],\n    'MASERATI': ['MASERATI', 'MAS'],\n    'FERRARI': ['FERRARI', 'FER'],\n    'LAMBORGHINI': ['LAMBORGHINI', 'LAMBO'],\n    'ASTON MARTIN': ['ASTON', 'ASTON MARTIN'],\n    'BENTLEY': ['BENTLEY', 'BENT'],\n    'ROLLS-ROYCE': ['ROLLS', 'ROLLS ROYCE', 'ROLLS-ROYCE'],\n    'BUICK': ['BUICK', 'BUI'],\n    'MG': ['MG', 'MORRIS GARAGES'],\n    'JAC': ['JAC', 'JAC MOTORS'],\n    'JMC': ['JMC', ' JMC'],  // Nota: hay un espacio en algunos registros\n    'BAIC': ['BAIC', 'BEIJING'],\n    'BYD': ['BYD', 'BUILD YOUR DREAMS'],\n    'CHANGAN': ['CHANGAN', 'CHANG AN'],\n    'CHIREY': ['CHIREY', 'CHERY'],\n    'GEELY': ['GEELY', 'GEE'],\n    'HAVAL': ['HAVAL', 'HAV'],\n    'JETOUR': ['JETOUR', 'JET'],\n    'OMODA': ['OMODA', 'OMO'],\n    'ORA': ['ORA', 'OR'],\n    'TANK': ['TANK', 'TNK'],\n    'ARRA': ['ARRA', 'ARR']  // Marca nueva en MAPFRE\n};\n\nconst MAPA_TRANSMISIONES = {\n    'Manual': 'MANUAL',\n    'Automática': 'AUTO',\n    'No especificada': 'NO_ESPECIFICADA'\n};\n\n// ==================================================\n// FUNCIONES DE NORMALIZACIÓN\n// ==================================================\n\nfunction normalizarMarca(marca) {\n    if (!marca || marca.trim() === '') return 'MARCA_DESCONOCIDA';\n    \n    // Limpiar espacios al inicio\n    const marcaLimpia = marca.trim();\n    const marcaUpper = marcaLimpia.toUpperCase();\n    \n    // Buscar en el diccionario\n    for (const [canonical, variations] of Object.entries(MARCAS_CANONICAS)) {\n        if (variations.some(v => marcaUpper === v || marcaUpper.includes(v))) {\n            return canonical;\n        }\n    }\n    \n    return marcaUpper;\n}\n\nfunction normalizarTexto(texto) {\n    if (!texto || texto.trim() === '') return '';\n    \n    return texto\n        .toUpperCase()\n        .trim()\n        .replace(/\\s+/g, ' ')\n        .replace(/[^\\w\\s\\-]/g, '')\n        .trim();\n}\n\n// FUNCIÓN CRÍTICA: Extraer y normalizar versión con formato de guiones\nfunction extraerVersionReal(versionCorta) {\n    if (!versionCorta || versionCorta === 'STANDARD') return 'STANDARD';\n    \n    let desc = versionCorta.toUpperCase().trim();\n    \n    // PRIMERO: Normalizar versiones multi-palabra a formato con guión\n    const normalizaciones = [\n        // Correcciones tipográficas específicas de MAPFRE\n        { buscar: /\\bA-SPECH\\b/g, reemplazar: 'A-SPEC' },\n        { buscar: /\\bA SPEC\\b/g, reemplazar: 'A-SPEC' },\n        { buscar: /\\bA-SPEC\\b/g, reemplazar: 'A-SPEC' },\n        { buscar: /\\bTYPE S\\b/g, reemplazar: 'TYPE-S' },\n        { buscar: /\\bTYPE-S\\b/g, reemplazar: 'TYPE-S' },\n        { buscar: /\\bTYPE R\\b/g, reemplazar: 'TYPE-R' },\n        { buscar: /\\bTYPE-R\\b/g, reemplazar: 'TYPE-R' },\n        { buscar: /\\bS LINE\\b/g, reemplazar: 'S-LINE' },\n        { buscar: /\\bS-LINE\\b/g, reemplazar: 'S-LINE' },\n        { buscar: /\\bRS LINE\\b/g, reemplazar: 'RS-LINE' },\n        { buscar: /\\bRS-LINE\\b/g, reemplazar: 'RS-LINE' },\n        { buscar: /\\bR LINE\\b/g, reemplazar: 'R-LINE' },\n        { buscar: /\\bR-LINE\\b/g, reemplazar: 'R-LINE' },\n        { buscar: /\\bAMG LINE\\b/g, reemplazar: 'AMG-LINE' },\n        { buscar: /\\bAMG-LINE\\b/g, reemplazar: 'AMG-LINE' },\n        { buscar: /\\bM SPORT\\b/g, reemplazar: 'M-SPORT' },\n        { buscar: /\\bM-SPORT\\b/g, reemplazar: 'M-SPORT' },\n        { buscar: /\\bM PERFORMANCE\\b/g, reemplazar: 'M-PERFORMANCE' },\n        { buscar: /\\bBLACK LABEL\\b/g, reemplazar: 'BLACK-LABEL' },\n        { buscar: /\\bGRAND TOURING\\b/g, reemplazar: 'GRAND-TOURING' },\n        { buscar: /\\bJOHN COOPER WORKS\\b/g, reemplazar: 'JOHN-COOPER-WORKS' },\n        { buscar: /\\bLAUNCH EDITION\\b/g, reemplazar: 'LAUNCH-EDITION' },\n        { buscar: /\\bFIRST EDITION\\b/g, reemplazar: 'FIRST-EDITION' },\n        { buscar: /\\bSPECIAL EDITION\\b/g, reemplazar: 'SPECIAL-EDITION' },\n        { buscar: /\\bLIMITED EDITION\\b/g, reemplazar: 'LIMITED-EDITION' },\n        { buscar: /\\bR DYNAMIC\\b/g, reemplazar: 'R-DYNAMIC' },\n        { buscar: /\\bR-DYNAMIC\\b/g, reemplazar: 'R-DYNAMIC' }\n    ];\n    \n    // Aplicar normalizaciones\n    for (let norm of normalizaciones) {\n        desc = desc.replace(norm.buscar, norm.reemplazar);\n    }\n    \n    // SEGUNDO: Remover información técnica y de transmisión\n    const infoTecnica = [\n        /\\bTA\\b/g,             // TA (transmisión automática)\n        /\\bTM\\b/g,             // TM (transmisión manual)\n        /\\bAT\\b/g,             // AT (automática)\n        /\\bMT\\b/g,             // MT (manual)\n        /\\bAUT\\b/g,            // AUT\n        /\\bSTD\\b/g,            // STD\n        /\\bCVT\\b/g,            // CVT\n        /\\bDCT\\b/g,            // DCT\n        /\\bDSG\\b/g,            // DSG\n        /\\b\\d+\\.\\d+L?\\b/g,     // 1.5L, 2.0L, 3.5L\n        /\\bL\\d+\\b/g,           // L4, L6\n        /\\bV\\d+\\b/g,           // V6, V8\n        /\\b\\d+CIL\\b/g,         // 4CIL, 6CIL\n        /\\b\\d+P\\b/g,           // 2P, 4P, 5P\n        /\\b4X4\\b/g,            // 4X4\n        /\\b4X2\\b/g,            // 4X2\n        /\\b4WD\\b/g,            // 4WD\n        /\\bAWD\\b/g,            // AWD\n        /\\bFWD\\b/g,            // FWD\n        /\\bRWD\\b/g,            // RWD\n        /\\bTURBO\\b/g,          // TURBO\n        /\\bTFSI\\b/g,           // TFSI\n        /\\bTSI\\b/g,            // TSI\n        /\\bTDI\\b/g,            // TDI\n        /\\bHYBRID\\b/g,         // HYBRID\n        /\\bPLUG-IN\\b/g,        // PLUG-IN\n        /\\bBEV\\b/g,            // BEV (Battery Electric Vehicle)\n        /\\bMHEV\\b/g            // MHEV (Mild Hybrid)\n    ];\n    \n    // Limpiar información técnica\n    let limpio = desc;\n    for (let pattern of infoTecnica) {\n        limpio = limpio.replace(pattern, ' ');\n    }\n    \n    // Limpiar espacios múltiples\n    limpio = limpio.replace(/\\s+/g, ' ').trim();\n    \n    // Si después de limpiar queda algo significativo, retornarlo\n    if (limpio && limpio.length > 1) {\n        // Verificar si es una versión normalizada conocida\n        const versionesNormalizadas = [\n            'A-SPEC', 'TYPE-S', 'TYPE-R', 'S-LINE', 'RS-LINE', \n            'R-LINE', 'AMG-LINE', 'M-SPORT', 'M-PERFORMANCE',\n            'BLACK-LABEL', 'GRAND-TOURING', 'JOHN-COOPER-WORKS',\n            'LAUNCH-EDITION', 'FIRST-EDITION', 'SPECIAL-EDITION',\n            'LIMITED-EDITION', 'R-DYNAMIC'\n        ];\n        \n        // Si encontramos una versión normalizada, retornarla\n        for (let version of versionesNormalizadas) {\n            if (limpio.includes(version)) {\n                return version;\n            }\n        }\n        \n        // Buscar versiones simples conocidas\n        const versionesSimples = [\n            'ADVANCE', 'TECH', 'BASE', 'SPORT', 'PREMIUM', \n            'ELITE', 'LIMITED', 'EXCLUSIVE', 'LUXURY',\n            'GTI', 'ST', 'SRT', 'RS', 'AMG', 'NISMO',\n            'DENALI', 'RUBICON', 'SAHARA', 'TRAILHAWK',\n            'COMPETITION', 'PERFORMANCE', 'QUADRIFOGLIO',\n            'BLACK', 'VELOCE', 'LUSSO', 'PROGRESSIV',\n            'HIGHLINE', 'COMFORTLINE', 'TRENDLINE',\n            'PLATINUM', 'TITANIUM', 'SELECT', 'DYNAMIC'\n        ];\n        \n        for (let version of versionesSimples) {\n            if (limpio === version || limpio.startsWith(version + ' ')) {\n                return version;\n            }\n        }\n        \n        // Si queda algo después de limpiar, tomar la primera palabra\n        const palabras = limpio.split(' ').filter(p => p.length > 1);\n        if (palabras.length > 0) {\n            return palabras[0];\n        }\n    }\n    \n    return 'STANDARD';\n}\n\n// FUNCIÓN ESPECÍFICA PARA MAPFRE: Detectar transmisión\nfunction detectarTransmisionMapfre(versionCompleta, versionCorta) {\n    const textoCompleto = `${versionCompleta || ''} ${versionCorta || ''}`.toUpperCase();\n    \n    // Patrones específicos de MAPFRE\n    const patronesManual = [\n        /\\bTM\\b/,      // TM solo\n        /\\bMT\\b/,      // MT solo\n        /\\bMANUAL\\b/,  // MANUAL\n        /\\bSTD\\b/,     // STD\n        /\\b5MT\\b/,     // 5MT\n        /\\b6MT\\b/      // 6MT\n    ];\n    \n    const patronesAuto = [\n        /\\bTA\\b/,      // TA solo\n        /\\bAT\\b/,      // AT solo\n        /\\bAUT\\b/,     // AUT\n        /\\bAUTO\\b/,    // AUTO\n        /\\bCVT\\b/,     // CVT\n        /\\bDCT\\b/,     // DCT\n        /\\bDSG\\b/,     // DSG\n        /\\bTIPTRONIC/, // TIPTRONIC\n        /\\bSTRONIC/    // STRONIC\n    ];\n    \n    // Verificar manual\n    const tieneManual = patronesManual.some(patron => patron.test(textoCompleto));\n    const tieneAuto = patronesAuto.some(patron => patron.test(textoCompleto));\n    \n    if (tieneManual && !tieneAuto) {\n        return 'MANUAL';\n    }\n    if (tieneAuto && !tieneManual) {\n        return 'AUTO';\n    }\n    \n    return 'NO_ESPECIFICADA';\n}\n\n// Función para normalizar transmisión\nfunction normalizarTransmision(transmisionDesc, transmisionCodigo, versionCompleta, versionCorta) {\n    // Si tiene código confiable (1 o 2), usarlo\n    if (transmisionCodigo === 1) return 'MANUAL';\n    if (transmisionCodigo === 2) return 'AUTO';\n    \n    // Si hay descripción válida\n    if (transmisionDesc && transmisionDesc !== 'No especificada') {\n        return MAPA_TRANSMISIONES[transmisionDesc] || 'NO_ESPECIFICADA';\n    }\n    \n    // Para MAPFRE: Intentar detectar desde las descripciones\n    const transmisionDetectada = detectarTransmisionMapfre(versionCompleta, versionCorta);\n    \n    return transmisionDetectada;\n}\n\n// Función para generar hash único\nfunction generarHash(...componentes) {\n    const textoHash = componentes\n        .map(c => String(c || '').toUpperCase().trim())\n        .filter(c => c !== '' && c !== 'MODELO_DESCONOCIDO' && c !== 'MARCA_DESCONOCIDA')\n        .join('|');\n    \n    if (textoHash === '') {\n        return crypto\n            .createHash('sha256')\n            .update(`EMPTY_${Date.now()}_${Math.random()}`, 'utf8')\n            .digest('hex');\n    }\n    \n    return crypto\n        .createHash('sha256')\n        .update(textoHash, 'utf8')\n        .digest('hex');\n}\n\n// ==================================================\n// PROCESAMIENTO PRINCIPAL MAPFRE\n// ==================================================\nconst items = $input.all();\nconst registros = [];\nconst fechaProceso = new Date().toISOString();\n\n// Estadísticas\nlet stats = {\n    total: 0,\n    procesados: 0,\n    rechazados: 0,\n    sinModelo: 0,\n    sinTransmision: 0,\n    transmisionDetectada: 0\n};\n\nfor (const item of items) {\n    const data = item.json;\n    stats.total++;\n    \n    // Validaciones básicas\n    if (!data.marca || data.marca === 'MARCA_DESCONOCIDA') {\n        stats.rechazados++;\n        continue;\n    }\n    \n    if (!data.año || data.año < 2000 || data.año > 2026) {\n        stats.rechazados++;\n        continue;\n    }\n    \n    // Validar que tengamos modelo\n    if (!data.modelo || data.modelo.startsWith('MODELO_')) {\n        stats.sinModelo++;\n        continue;\n    }\n    \n    // Normalización de marca\n    const marcaNormalizada = normalizarMarca(data.marca);\n    \n    // Normalización de modelo\n    const modeloNormalizado = normalizarTexto(data.modelo);\n    \n    // Extracción y normalización de versión\n    const versionNormalizada = extraerVersionReal(data.version_corta);\n    \n    // Normalización de transmisión\n    const transmisionNormalizada = normalizarTransmision(\n        data.transmision_descripcion,\n        data.transmision_codigo,\n        data.version_completa,\n        data.version_corta\n    );\n    \n    // Estadísticas de transmisión\n    if (transmisionNormalizada === 'NO_ESPECIFICADA') {\n        stats.sinTransmision++;\n    }\n    if (data.transmision_original === 0 && transmisionNormalizada !== 'NO_ESPECIFICADA') {\n        stats.transmisionDetectada++;\n    }\n    \n    // Generar hash único\n    const hashUnico = generarHash(\n        marcaNormalizada,\n        modeloNormalizado,\n        data.año,\n        versionNormalizada,\n        transmisionNormalizada\n    );\n    \n    // Estructura de salida consistente con otros ETL\n    const registro = {\n        // Campos principales\n        hash_unico: hashUnico,\n        marca: data.marca,\n        modelo: data.modelo,  // Modelo ya limpio del query\n        año: data.año,\n        version: data.version_completa,\n        version_corta: data.version_corta || null,\n        transmision_codigo: data.transmision_codigo,\n        transmision_descripcion: data.transmision_descripcion,\n        transmision_normalizada: transmisionNormalizada,\n        transmision_original: data.transmision_original,\n        transmision_detectada_desc: data.transmision_detectada_desc === 1,\n        \n        // Campos normalizados - CRÍTICOS PARA HASH\n        marca_normalizada: marcaNormalizada,\n        modelo_normalizado: modeloNormalizado,\n        version_normalizada: versionNormalizada,\n        version_corta_normalizada: versionNormalizada,\n        \n        // IDs de catálogo\n        catalogo_marca_id: data.catalogo_marca_id,\n        catalogo_modelo_id: data.catalogo_modelo_id,\n        catalogo_version_id: data.catalogo_version_id || null,\n        \n        // Metadatos\n        origen_carga: 'etl_mapfre_batch',\n        fecha_proceso: fechaProceso,\n        \n        // Datos específicos de aseguradora\n        aseguradora_data: {\n            aseguradora: ASEGURADORA,\n            id_original: data.id_original,\n            activo: data.activo !== undefined ? data.activo : 1,\n            fecha_actualizacion: data.fecha_actualizacion,\n            transmision_original: data.transmision_original,\n            transmision_detectada_automaticamente: data.transmision_detectada_desc === 1\n        },\n        \n        // Componentes del hash - CRÍTICO para homologación\n        hash_components: {\n            marca: marcaNormalizada,\n            modelo: modeloNormalizado,\n            año: data.año ? data.año.toString() : 'SIN_AÑO',\n            version: versionNormalizada,\n            transmision: transmisionNormalizada\n        }\n    };\n    \n    registros.push(registro);\n    stats.procesados++;\n}\n\n// Retornar en formato n8n correcto\nreturn registros.map(registro => ({ json: registro }));"
      },
      "id": "c72d0b04-ba49-4b14-a281-7ca1be36a1ac",
      "name": "Normalize Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -784,
        544
      ]
    },
    {
      "parameters": {
        "jsCode": "// Nodo: Deduplicate Source Data\nconst items = $input.all();\nconst seen = new Map();\n\nfor (const item of items) {\n  const key = `${item.json.marca}|${item.json.modelo}|${item.json.año}|${item.json.version_completa}`;\n  \n  if (!seen.has(key) || item.json.fecha_actualizacion > seen.get(key).json.fecha_actualizacion) {\n    seen.set(key, item);\n  }\n}\n\nreturn Array.from(seen.values());"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -976,
        544
      ],
      "id": "7c651355-15a1-4b6d-b5d6-51355e8237b1",
      "name": "Deduplicate data"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- =====================================================\n-- QUERY DE EXTRACCIÓN PARA MAPFRE\n-- TODOS los registros (no tiene campo activo)\n-- Eliminar duplicados masivos con GROUP BY\n-- Total esperado: ~31,476 registros únicos\n-- =====================================================\n\nSELECT \n    'MAPFRE' as origen_aseguradora,\n    mo.CodModelo as id_original,\n    m.NomMarca as marca,\n    -- NomModelo contiene modelo + versión mezclados\n    mo.NomModelo as modelo_version_completo,\n    mo.AnioFabrica as anio,\n    mo.VersionCorta as version_corta,\n    CASE \n        WHEN mo.Transmision = 1 THEN 'MANUAL'\n        WHEN mo.Transmision = 2 THEN 'AUTO'\n        ELSE NULL  -- 30% sin transmisión especificada\n    END as transmision,\n    1 as activo  -- Todos se consideran activos\nFROM mapfre.Modelo mo\nINNER JOIN mapfre.Marca m ON mo.CodMarca = m.CodMarca\nWHERE \n    mo.AnioFabrica BETWEEN 2000 AND 2030\nGROUP BY \n    mo.CodModelo,\n    m.NomMarca, \n    mo.NomModelo, \n    mo.AnioFabrica, \n    mo.VersionCorta, \n    mo.Transmision\nORDER BY m.NomMarca, mo.NomModelo, mo.AnioFabrica"
      },
      "id": "ace5acd4-2c12-41e9-b916-7cca6253e895",
      "name": "Extract MAPFRE Data",
      "type": "n8n-nodes-base.microsoftSql",
      "typeVersion": 1,
      "position": [
        -1184,
        544
      ],
      "credentials": {
        "microsoftSql": {
          "id": "LxcRbE0XllWrNCsR",
          "name": "Microsoft SQL account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Nodo: Deduplicate by Hash - CRÍTICO para evitar duplicados\nconst items = $input.all();\nconst uniqueByHash = new Map();\nconst duplicates = new Map();\n\n// Procesar todos los items\nitems.forEach(item => {\n  const hash = item.json.hash_unico;\n  \n  if (!hash) {\n    return;\n  }\n  \n  if (uniqueByHash.has(hash)) {\n    // Contar duplicados\n    if (!duplicates.has(hash)) {\n      duplicates.set(hash, [uniqueByHash.get(hash)]);\n    }\n    duplicates.set(hash, [...duplicates.get(hash), item]);\n  } else {\n    uniqueByHash.set(hash, item);\n  }\n});\n\n// Reportar duplicados encontrados\nif (duplicates.size > 0) {  \n  // Mostrar ejemplos de duplicados\n  let exampleCount = 0;\n  for (const [hash, items] of duplicates.entries()) {\n    if (exampleCount >= 5) break;\n    \n    console.log(`\\n🔍 Hash duplicado: ${hash.substring(0, 16)}...`);\n    console.log(`   Registros: ${items.length}`);\n    \n    // Mostrar los primeros 2 registros del duplicado\n    items.slice(0, 2).forEach((item, idx) => {\n      const data = item.json;\n    });\n    \n    exampleCount++;\n  }\n  \n  // Análisis de por qué se duplican\n  const duplicateAnalysis = new Map();\n  for (const [hash, items] of duplicates.entries()) {\n    const firstItem = items[0].json;\n    const key = `${firstItem.marca_normalizada}|${firstItem.modelo_normalizado}`;\n    \n    if (!duplicateAnalysis.has(key)) {\n      duplicateAnalysis.set(key, 0);\n    }\n    duplicateAnalysis.set(key, duplicateAnalysis.get(key) + 1);\n  }\n  \n  const sortedAnalysis = Array.from(duplicateAnalysis.entries())\n    .sort((a, b) => b[1] - a[1])\n    .slice(0, 10);\n  \n  sortedAnalysis.forEach(([key, count]) => {\n    console.log(`   ${key}: ${count} hashes duplicados`);\n  });\n}\n\n// Estadísticas finales\nconst finalItems = Array.from(uniqueByHash.values());\n\nreturn finalItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -576,
        544
      ],
      "id": "b2e09215-469f-444c-a6d6-104a6386bafb",
      "name": "Deduplicate by Hash"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.convertToFile",
      "typeVersion": 1.1,
      "position": [
        -976,
        736
      ],
      "id": "7d395766-8220-4542-b639-7c7871cd46af",
      "name": "Convert to File"
    }
  ],
  "pinData": {
    "When clicking ‘Execute workflow’": [
      {
        "json": {}
      }
    ]
  },
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "Extract MAPFRE Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normalize Data": {
      "main": [
        [
          {
            "node": "Deduplicate by Hash",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate data": {
      "main": [
        [
          {
            "node": "Normalize Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract MAPFRE Data": {
      "main": [
        [
          {
            "node": "Convert to File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate by Hash": {
      "main": [
        []
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "5c75015c-a168-407f-8036-5e116c9afbac",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "900709ac205bf412bdd7b3d4452073dce9dfbb650e50cd24da57187d1da44e89"
  },
  "id": "xcPdfoxQPNbfpS3X",
  "tags": []
}